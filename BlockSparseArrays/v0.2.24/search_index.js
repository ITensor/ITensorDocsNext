var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#BlockSparseArrays.SVD","page":"Reference","title":"BlockSparseArrays.SVD","text":"SVD <: Factorization\n\nMatrix factorization type of the singular value decomposition (SVD) of a matrix A. This is the return type of svd(_), the corresponding matrix factorization function.\n\nIf F::SVD is the factorization object, U, S, V and Vt can be obtained via F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt. The singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> F = BlockSparseArrays.svd(A)\nBlockSparseArrays.SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}, Matrix{Float64}}\nU factor:\n4×4 Matrix{Float64}:\n 0.0  1.0   0.0  0.0\n 1.0  0.0   0.0  0.0\n 0.0  0.0   0.0  1.0\n 0.0  0.0  -1.0  0.0\nsingular values:\n4-element Vector{Float64}:\n 3.0\n 2.23606797749979\n 2.0\n 0.0\nVt factor:\n4×5 Matrix{Float64}:\n -0.0        0.0  1.0  -0.0  0.0\n  0.447214   0.0  0.0   0.0  0.894427\n  0.0       -1.0  0.0   0.0  0.0\n  0.0        0.0  0.0   1.0  0.0\n\njulia> F.U * Diagonal(F.S) * F.Vt\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> u, s, v = F; # destructuring via iteration\n\njulia> u == F.U && s == F.S && v == F.V\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.svd!-Tuple{Any}","page":"Reference","title":"BlockSparseArrays.svd!","text":"svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD\n\nsvd! is the same as svd, but saves space by overwriting the input A, instead of creating a copy. See documentation of svd for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlockSparseArrays.svd-Tuple{Any}","page":"Reference","title":"BlockSparseArrays.svd","text":"svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD\n\nCompute the singular value decomposition (SVD) of A and return an SVD object.\n\nU, S, V and Vt can be obtained from the factorization F with F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt. The algorithm produces Vt and hence Vt is more efficient to extract than V. The singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nIf full = false (default), a \"thin\" SVD is returned. For an M times N matrix A, in the full factorization U is M times M and V is N times N, while in the thin factorization U is M times K and V is N times K, where K = min(MN) is the number of singular values.\n\nalg specifies which algorithm and LAPACK method to use for SVD:\n\nalg = DivideAndConquer() (default): Calls LAPACK.gesdd!.\nalg = QRIteration(): Calls LAPACK.gesvd! (typically slower but more accurate) .\n\ncompat: Julia 1.3\nThe alg keyword argument requires Julia 1.3 or later.\n\nExamples\n\njulia> A = rand(4,3);\n\njulia> F = BlockSparseArrays.svd(A); # Store the Factorization Object\n\njulia> A ≈ F.U * Diagonal(F.S) * F.Vt\ntrue\n\njulia> U, S, V = F; # destructuring via iteration\n\njulia> A ≈ U * Diagonal(S) * V'\ntrue\n\njulia> Uonly, = BlockSparseArrays.svd(A); # Store U only\n\njulia> Uonly == U\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#BlockSparseArrays.jl","page":"Home","title":"BlockSparseArrays.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)\n\nA block sparse array type in Julia based on the BlockArrays.jl interface.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"BlockSparseArrays\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using BlockArrays: BlockArrays, BlockedVector, Block, blockedrange\nusing BlockSparseArrays: BlockSparseArray, blockstoredlength\nusing Test: @test, @test_broken\n\nfunction main()\n  # Block dimensions\n  i1 = [2, 3]\n  i2 = [2, 3]\n\n  i_axes = (blockedrange(i1), blockedrange(i2))\n\n  function block_size(axes, block)\n    return length.(getindex.(axes, Block.(block.n)))\n  end\n\n  # Data\n  nz_blocks = Block.([(1, 1), (2, 2)])\n  nz_block_sizes = [block_size(i_axes, nz_block) for nz_block in nz_blocks]\n  nz_block_lengths = prod.(nz_block_sizes)\n\n  # Blocks with contiguous underlying data\n  d_data = BlockedVector(randn(sum(nz_block_lengths)), nz_block_lengths)\n  d_blocks = [\n    reshape(@view(d_data[Block(i)]), block_size(i_axes, nz_blocks[i])) for\n    i in 1:length(nz_blocks)\n  ]\n  b = BlockSparseArray(nz_blocks, d_blocks, i_axes)\n\n  @test blockstoredlength(b) == 2\n\n  # Blocks with discontiguous underlying data\n  d_blocks = randn.(nz_block_sizes)\n  b = BlockSparseArray(nz_blocks, d_blocks, i_axes)\n\n  @test blockstoredlength(b) == 2\n\n  # Access a block\n  @test b[Block(1, 1)] == d_blocks[1]\n\n  # Access a zero block, returns a zero matrix\n  @test b[Block(1, 2)] == zeros(2, 3)\n\n  # Set a zero block\n  a₁₂ = randn(2, 3)\n  b[Block(1, 2)] = a₁₂\n  @test b[Block(1, 2)] == a₁₂\n\n  # Matrix multiplication\n  @test b * b ≈ Array(b) * Array(b)\n\n  permuted_b = permutedims(b, (2, 1))\n  @test permuted_b isa BlockSparseArray\n  @test permuted_b == permutedims(Array(b), (2, 1))\n\n  @test b + b ≈ Array(b) + Array(b)\n  @test b + b isa BlockSparseArray\n  # TODO: Fix this, broken.\n  @test_broken blockstoredlength(b + b) == 2\n\n  scaled_b = 2b\n  @test scaled_b ≈ 2Array(b)\n  @test scaled_b isa BlockSparseArray\n\n  # TODO: Fix this, broken.\n  @test_broken reshape(b, ([4, 6, 6, 9],)) isa BlockSparseArray{<:Any,1}\n\n  return nothing\nend\n\nmain()","category":"section"},{"location":"#BlockSparseArrays.jl-and-BlockArrays.jl-interface","page":"Home","title":"BlockSparseArrays.jl and BlockArrays.jl interface","text":"using BlockArrays: BlockArrays, Block\nusing BlockSparseArrays: BlockSparseArray\n\ni1 = [2, 3]\ni2 = [2, 3]\nB = BlockSparseArray{Float64}(i1, i2)\nB[Block(1, 1)] = randn(2, 2)\nB[Block(2, 2)] = randn(3, 3)\n\n# Minimal interface\n\n# Specifies the block structure\n@show collect.(BlockArrays.blockaxes(axes(B, 1)))\n\n# Index range of a block\n@show axes(B, 1)[Block(1)]\n\n# Last index of each block\n@show BlockArrays.blocklasts(axes(B, 1))\n\n# Find the block containing the index\n@show BlockArrays.findblock(axes(B, 1), 3)\n\n# Retrieve a block\n@show B[Block(1, 1)]\n@show BlockArrays.viewblock(B, Block(1, 1))\n\n# Check block bounds\n@show BlockArrays.blockcheckbounds(B, 2, 2)\n@show BlockArrays.blockcheckbounds(B, Block(2, 2))\n\n# Derived interface\n\n# Specifies the block structure\n@show collect(Iterators.product(BlockArrays.blockaxes(B)...))\n\n# Iterate over block views\n@show sum.(BlockArrays.eachblock(B))\n\n# Reshape into 1-d\n# TODO: Fix this, broken.\n# @show BlockArrays.blockvec(B)[Block(1)]\n\n# Array-of-array view\n@show BlockArrays.blocks(B)[1, 1] == B[Block(1, 1)]\n\n# Access an index within a block\n@show B[Block(1, 1)[1, 1]] == B[1, 1]\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
