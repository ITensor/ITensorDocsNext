var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#BlockSparseArrays.BlockPermutedDiagonalAlgorithm","page":"Reference","title":"BlockSparseArrays.BlockPermutedDiagonalAlgorithm","text":"BlockPermutedDiagonalAlgorithm(A::MatrixAlgebraKit.AbstractAlgorithm)\n\nA wrapper for MatrixAlgebraKit.AbstractAlgorithm that implements the wrapped algorithm on a block-by-block basis, which is possible if the input matrix is a block-diagonal matrix or a block permuted block-diagonal matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.BlockPermutedDiagonalTruncationStrategy","page":"Reference","title":"BlockSparseArrays.BlockPermutedDiagonalTruncationStrategy","text":"BlockPermutedDiagonalTruncationStrategy(strategy::TruncationStrategy)\n\nA wrapper for TruncationStrategy that implements the wrapped strategy on a block-by-block basis, which is possible if the input matrix is a block-diagonal matrix or a block permuted block-diagonal matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.BlockSparseArray","page":"Reference","title":"BlockSparseArrays.BlockSparseArray","text":"BlockSparseArray{T}(undef, dims)\nBlockSparseArray{T,N}(undef, dims)\nBlockSparseArray{T,N,A}(undef, dims)\n\nConstruct an uninitialized N-dimensional BlockSparseArray containing elements of type T. dims should be a list of block lengths in each dimension or a list of blocked ranges representing the axes.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SparseArraysBase.SparseArrayDOK-Union{Tuple{N}, Tuple{T}, Tuple{BlockArrays.UndefBlocksInitializer, NTuple{N, AbstractUnitRange{<:Integer}}}} where {T, N}","page":"Reference","title":"SparseArraysBase.SparseArrayDOK","text":"SparseArrayDOK{T}(undef_blocks, axes)\nSparseArrayDOK{T,N}(undef_blocks, axes)\n\nConstruct the block structure of an undefined BlockSparseArray that will have blocked axes axes.\n\nNote that undef_blocks is defined in BlockArrays.jl and should be imported from that package to use it as an input to this constructor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlockSparseArrays.sparsemortar-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{<:AbstractArray{T, N}, N}, NTuple{N, AbstractUnitRange{<:Integer}}}} where {T, N}","page":"Reference","title":"BlockSparseArrays.sparsemortar","text":"sparsemortar(blocks::AbstractArray{<:AbstractArray{T,N},N}, axes) -> ::BlockSparseArray{T,N}\n\nConstruct a block sparse array from a sparse array of arrays and specified blocked axes. The block sizes must be commensurate with the blocks of the axes.\n\n\n\n\n\n","category":"method"},{"location":"#BlockSparseArrays.jl","page":"Home","title":"BlockSparseArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A block sparse array type in Julia based on the BlockArrays.jl interface.","category":"page"},{"location":"#Support","page":"Home","title":"Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"BlockSparseArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the package can be added as usual through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"BlockSparseArrays\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BlockArrays: Block\nusing BlockSparseArrays: BlockSparseArray, blockstoredlength\nusing Test: @test\n\na = BlockSparseArray{Float64}(undef, [2, 3], [2, 3])\na[Block(1, 2)] = randn(2, 3)\na[Block(2, 1)] = randn(3, 2)\n@test blockstoredlength(a) == 2\nb = a .+ 2 .* a'\n@test Array(b) â‰ˆ Array(a) + 2 * Array(a')\n@test blockstoredlength(b) == 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"}]
}
