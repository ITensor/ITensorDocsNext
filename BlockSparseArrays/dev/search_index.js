var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#BlockSparseArrays.BlockDiagonalAlgorithm","page":"Reference","title":"BlockSparseArrays.BlockDiagonalAlgorithm","text":"BlockDiagonalAlgorithm([f]) <: MatrixAlgebraKit.AbstractAlgorithm\n\nType for handling algorithms on a block-by-block basis, which is possible for block-diagonal input matrices. Additionally this algorithm may take a function that, given the individual blocks, returns the algorithm that will be used. This can be leveraged to allow for different algorithms for each block.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.BlockDiagonalTruncationStrategy","page":"Reference","title":"BlockSparseArrays.BlockDiagonalTruncationStrategy","text":"BlockDiagonalTruncationStrategy(strategy::TruncationStrategy)\n\nA wrapper for TruncationStrategy that implements the wrapped strategy on a block-by-block basis, which is possible if the input matrix is a block-diagonal matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.BlockPermutedDiagonalAlgorithm","page":"Reference","title":"BlockSparseArrays.BlockPermutedDiagonalAlgorithm","text":"BlockPermutedDiagonalAlgorithm([f]) <: MatrixAlgebraKit.AbstractAlgorithm\n\nType for handling algorithms on a block-by-block basis, which is possible for block-diagonal or block-permuted-diagonal input matrices. The algorithms proceed by first permuting to a block-diagonal form, and then carrying out the algorithm. Additionally this algorithm may take a function that, given the individual blocks, returns the algorithm that will be used. This can be leveraged to allow for different algorithms for each block.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.BlockSparseArray","page":"Reference","title":"BlockSparseArrays.BlockSparseArray","text":"BlockSparseArray{T}(undef, dims)\nBlockSparseArray{T,N}(undef, dims)\nBlockSparseArray{T,N,A}(undef, dims)\n\nConstruct an uninitialized N-dimensional BlockSparseArray containing elements of type T. dims should be a list of block lengths in each dimension or a list of blocked ranges representing the axes.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SparseArraysBase.SparseArrayDOK-Union{Tuple{N}, Tuple{T}, Tuple{BlockArrays.UndefBlocksInitializer, NTuple{N, AbstractUnitRange{<:Integer}}}} where {T, N}","page":"Reference","title":"SparseArraysBase.SparseArrayDOK","text":"SparseArrayDOK{T}(undef_blocks, axes)\nSparseArrayDOK{T,N}(undef_blocks, axes)\n\nConstruct the block structure of an undefined BlockSparseArray that will have blocked axes axes.\n\nNote that undef_blocks is defined in BlockArrays.jl and should be imported from that package to use it as an input to this constructor.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlockSparseArrays.sparsemortar-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{<:AbstractArray{T, N}, N}, NTuple{N, AbstractUnitRange{<:Integer}}}} where {T, N}","page":"Reference","title":"BlockSparseArrays.sparsemortar","text":"sparsemortar(blocks::AbstractArray{<:AbstractArray{T,N},N}, axes) -> ::BlockSparseArray{T,N}\n\nConstruct a block sparse array from a sparse array of arrays and specified blocked axes. The block sizes must be commensurate with the blocks of the axes.\n\n\n\n\n\n","category":"method"},{"location":"#BlockSparseArrays.jl","page":"Home","title":"BlockSparseArrays.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style) (Image: Aqua)\n\nA block sparse array type in Julia based on the BlockArrays.jl interface.","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nBlockSparseArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"BlockSparseArrays\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using BlockArrays: Block\nusing BlockSparseArrays: BlockSparseArray, blockstoredlength\nusing Test: @test\n\na = BlockSparseArray{Float64}(undef, [2, 3], [2, 3])\na[Block(1, 2)] = randn(2, 3)\na[Block(2, 1)] = randn(3, 2)\n@test blockstoredlength(a) == 2\nb = a .+ 2 .* a'\n@test Array(b) â‰ˆ Array(a) + 2 * Array(a')\n@test blockstoredlength(b) == 2\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
