var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#GradedArrays.GradedOneTo","page":"Reference","title":"GradedArrays.GradedOneTo","text":"const GradedOneTo{I, R1, R2} = BlockOneTo{Int, Vector{SectorUnitRange{I, R1, R2}}, Vector{Int}}\n\nSee also SectorUnitRange and GradedUnitRange.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.GradedUnitRange","page":"Reference","title":"GradedArrays.GradedUnitRange","text":"const GradedUnitRange{I, R1, R2} = BlockUnitRange{Int, Vector{SectorUnitRange{I, R1, R2}}, Vector{Int}}\n\nType alias for the axis type of graded arrays. This represents the blocked combination of ranges, where each block is a SectorUnitRange with sector labels of type I and underlying range types R1 and R2.\n\nSee also SectorUnitRange and GradedOneTo.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.SectorArray","page":"Reference","title":"GradedArrays.SectorArray","text":"SectorArray(sectors, data) <: AbstractKroneckerArray\n\nA representation of a general symmetric array as the combination of a structural part (sectors) and a data part (data). This can be thought of as a direct implementation of the Wigner-Eckart theorem.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.SectorDelta","page":"Reference","title":"GradedArrays.SectorDelta","text":"SectorDelta{T}(sectors::NTuple{N, I}) <: AbstractArray{T, N}\n\nAn immutable representation of the structural tensor associated to the representation space of a number of sectors. For abelian symmetries, this boils down to a scalar which can always be normalized to 1.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.SectorOneTo","page":"Reference","title":"GradedArrays.SectorOneTo","text":"const SectorOneTo{I <: SectorRange} = SectorUnitRange{I, Base.OneTo{Int}, Base.OneTo{Int}}\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.SectorRange","page":"Reference","title":"GradedArrays.SectorRange","text":"SectorRange(sector::TKS.Sector, isdual::Bool)\n\nUnit range with elements of type Int that additionally stores a sector to denote the grading. Equivalent to Base.OneTo(length(sector)). Additionally holds a flag to denote the duality.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.SectorUnitRange","page":"Reference","title":"GradedArrays.SectorUnitRange","text":"const SectorUnitRange{I <: SectorRange, RB <: AbstractUnitRange{Int}, R <: AbstractUnitRange{Int}} =\n    CartesianProductUnitRange{Int, I, RB, R}\n\nType alias for the cartesian product of a sector range of type I, and a unit range of type RB, which yields a total range of type R.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradedArrays.flux","page":"Reference","title":"GradedArrays.flux","text":"flux(a::AbstractArray)\nflux(a::AbstractArray, I::Block...)\n\nCompute the total flux of an AbstractArray, defined as the fusion of all of the incoming charges, or the flux associated to a provided block. Whenever the flux cannot be meaningfully computed, for example for non-graded arrays, or empty ones, this function returns UndefinedFlux.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GradedArrays.gradedrange-Tuple{AbstractVector{<:Pair}}","page":"Reference","title":"GradedArrays.gradedrange","text":"gradedrange(xs::AbstractVector{<:Pair})\n\nConstruct a graded range from the provided list of sector => range pairs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GradedArrays.sectorrange","page":"Reference","title":"GradedArrays.sectorrange","text":"sectorrange(sector, range)\nsectorrange(sector, dim)\n\nConstruct a SectorUnitRange for the given sector and dimension or range.\n\n\n\n\n\n","category":"function"},{"location":"#GradedArrays.jl","page":"Home","title":"GradedArrays.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nGradedArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"GradedArrays\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using GradedArrays: GradedArrays\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
