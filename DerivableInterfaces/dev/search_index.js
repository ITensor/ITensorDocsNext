var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [DerivableInterfaces, DerivableInterfaces.Concatenate]","category":"page"},{"location":"reference/#DerivableInterfaces.zero!","page":"Reference","title":"DerivableInterfaces.zero!","text":"zero!(x::AbstractArray)\n\nIn-place version of Base.zero.\n\n\n\n\n\n","category":"function"},{"location":"reference/#DerivableInterfaces.Concatenate","page":"Reference","title":"DerivableInterfaces.Concatenate","text":"module Concatenate\n\nAlternative implementation for Base.cat through cat(!).\n\nThis is mostly a copy of the Base implementation, with the main difference being that the destination is chosen based on all inputs instead of just the first.\n\nAdditionally, we have an intermediate representation in terms of a Concatenated object, reminiscent of how Broadcast works.\n\nThe various entry points for specializing behavior are:\n\nDestination selection can be achieved through\nBase.similar(concat::Concatenated{Interface}, ::Type{T}, axes) where {Interface}\nCustom implementations:\nBase.copy(concat::Concatenated{Interface}) # custom implementation of cat   Base.copyto!(dest, concat::Concatenated{Interface}) # custom implementation of cat! based on interface   Base.copyto!(dest, concat::Concatenated{Nothing}) # custom implementation of cat! based on typeof(dest)\n\n\n\n\n\n","category":"module"},{"location":"reference/#DerivableInterfaces.Concatenate.Concatenated","page":"Reference","title":"DerivableInterfaces.Concatenate.Concatenated","text":"Concatenated{Interface,Dims,Args<:Tuple}\n\nLazy representation of the concatenation of various Args along Dims, in order to provide hooks to customize the implementation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#DerivableInterfaces.Concatenate.cat!-Tuple{Any, Vararg{Any}}","page":"Reference","title":"DerivableInterfaces.Concatenate.cat!","text":"Concatenate.cat!(dest, args...; dims)\n\nConcatenate the supplied args along dimensions dims, placing the result into dest.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DerivableInterfaces.Concatenate.cat-Tuple","page":"Reference","title":"DerivableInterfaces.Concatenate.cat","text":"Concatenate.cat(args...; dims)\n\nConcatenate the supplied args along dimensions dims.\n\nSee also [concatenate] and cat!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#DerivableInterfaces.Concatenate.concatenate-Tuple{Any, Vararg{Any}}","page":"Reference","title":"DerivableInterfaces.Concatenate.concatenate","text":"concatenate(dims, args...)\n\nConcatenate the supplied args along dimensions dims.\n\nSee also [cat] and cat!.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"../../examples/README.jl\"","category":"page"},{"location":"#DerivableInterfaces.jl","page":"Home","title":"DerivableInterfaces.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a package for defining and deriving functionality for objects based around interfaces and traits, outside of the Julia type hierarchy. It is heavily inspired by Moshi.@derive, which itself is inspired by Rust's derive functionality, and the design of ArrayLayouts.jl. See also ForwardMethods.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The basic idea is to define implementations of a set of functions for a given interface, and types can overload, or derive, those implementations by specifying the desired interface. This provides a systematic way to define implementations of functions for objects that act in a certain way but may not share convenient abstact supertypes, such as a sparse array object and wrappers around that sparse array. Like in Moshi.jl and Rust's derive functionality, traits are simply sets of functions that can be derived for a certain type.","category":"page"},{"location":"#Support","page":"Home","title":"Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>","category":"page"},{"location":"","page":"Home","title":"Home","text":"DerivableInterfaces.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the package can be added as usual through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"DerivableInterfaces\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using DerivableInterfaces:\n  DerivableInterfaces, @array_aliases, @derive, @interface, interface\nusing Test: @test","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define an interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct SparseArrayInterface end","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define interface functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@interface ::SparseArrayInterface function Base.getindex(a, I::Int...)\n  checkbounds(a, I...)\n  !isstored(a, I...) && return getunstoredindex(a, I...)\n  return getstoredindex(a, I...)\nend\n@interface ::SparseArrayInterface function Base.setindex!(a, value, I::Int...)\n  checkbounds(a, I...)\n  iszero(value) && return a\n  if !isstored(a, I...)\n    setunstoredindex!(a, value, I...)\n    return a\n  end\n  setstoredindex!(a, value, I...)\n  return a\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define a type that will derive the interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct SparseArrayDOK{T,N} <: AbstractArray{T,N}\n  storage::Dict{CartesianIndex{N},T}\n  size::NTuple{N,Int}\nend\nstorage(a::SparseArrayDOK) = a.storage\nBase.size(a::SparseArrayDOK) = a.size\nfunction SparseArrayDOK{T}(size::Int...) where {T}\n  N = length(size)\n  return SparseArrayDOK{T,N}(Dict{CartesianIndex{N},T}(), size)\nend\nfunction isstored(a::SparseArrayDOK, I::Int...)\n  return CartesianIndex(I) in keys(storage(a))\nend\nfunction getstoredindex(a::SparseArrayDOK, I::Int...)\n  return storage(a)[CartesianIndex(I)]\nend\nfunction getunstoredindex(a::SparseArrayDOK, I::Int...)\n  return zero(eltype(a))\nend\nfunction setstoredindex!(a::SparseArrayDOK, value, I::Int...)\n  storage(a)[CartesianIndex(I)] = value\n  return a\nend\nfunction setunstoredindex!(a::SparseArrayDOK, value, I::Int...)\n  storage(a)[CartesianIndex(I)] = value\n  return a\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Specify the interface the type adheres to.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DerivableInterfaces.interface(::Type{<:SparseArrayDOK}) = SparseArrayInterface()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Define aliases like SparseMatrixDOK, AnySparseArrayDOK, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@array_aliases SparseArrayDOK","category":"page"},{"location":"","page":"Home","title":"Home","text":"DerivableInterfaces the interface for the type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@derive (T=SparseArrayDOK,) begin\n  Base.getindex(::T, ::Int...)\n  Base.setindex!(::T, ::Any, ::Int...)\nend\n\na = SparseArrayDOK{Float64}(2, 2)\na[1, 1] = 2\n@test a[1, 1] == 2\n@test a[2, 1] == 0\n@test a[1, 2] == 0\n@test a[2, 2] == 0\n\n@test a isa SparseMatrixDOK\n@test a' isa AnySparseMatrixDOK","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call the sparse array interface on a dense array.","category":"page"},{"location":"","page":"Home","title":"Home","text":"isstored(a::AbstractArray, I::Int...) = true\ngetstoredindex(a::AbstractArray, I::Int...) = getindex(a, I...)\nsetstoredindex!(a::AbstractArray, value, I::Int...) = setindex!(a, value, I...)\n\na = zeros(2, 2)\n@interface SparseArrayInterface() a[1, 1] = 2\n@test @interface(SparseArrayInterface(), a[1, 1]) == 2\n@test @interface(SparseArrayInterface(), a[2, 1]) == 0\n@test @interface(SparseArrayInterface(), a[1, 2]) == 0\n@test @interface(SparseArrayInterface(), a[2, 2]) == 0","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"}]
}
