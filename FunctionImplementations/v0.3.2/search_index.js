var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#FunctionImplementations.AbstractArrayStyle","page":"Reference","title":"FunctionImplementations.AbstractArrayStyle","text":"FunctionImplementations.AbstractArrayStyle <: Style is the abstract supertype for any style associated with an AbstractArray type.\n\nNote that if two or more AbstractArrayStyle subtypes conflict, the resulting style will fall back to that of Arrays. If this is undesirable, you may need to define binary Style rules to control the output type.\n\nSee also FunctionImplementations.DefaultArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionImplementations.DefaultArrayStyle","page":"Reference","title":"FunctionImplementations.DefaultArrayStyle","text":"FunctionImplementations.DefaultArrayStyle() is a FunctionImplementations.Style indicating that an object behaves as an array. Specifically, DefaultArrayStyle is used for any AbstractArray type that hasn't defined a specialized style, and in the absence of overrides from other arguments the resulting output type is Array.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionImplementations.Implementation","page":"Reference","title":"FunctionImplementations.Implementation","text":"FunctionImplementations.Implementation(f, s) wraps a function f with a style s. This can be used to create function implementations that behave differently based on the style of their arguments.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionImplementations.Style","page":"Reference","title":"FunctionImplementations.Style","text":"Style is an abstract type and trait-function used to determine behavior of objects. Style(typeof(x)) returns the style associated with x. To customize the behavior of a type, one can declare a style by defining a type/method pair\n\nstruct MyContainerStyle <: Style end\nFunctionImplementations.Style(::Type{<:MyContainer}) = MyContainerStyle()\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionImplementations.Style-Tuple{Any}","page":"Reference","title":"FunctionImplementations.Style","text":"(s::Style)(f)\n\nCalling a Style s with a function f as s(f) is a shorthand for creating a FunctionImplementations.Implementation object wrapping the function f with Style s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FunctionImplementations.Style-Union{Tuple{S}, Tuple{S, S}} where S<:FunctionImplementations.Style","page":"Reference","title":"FunctionImplementations.Style","text":"Style(::Style1, ::Style2) = Style3()\n\nIndicate how to resolve different Styles. For example,\n\nStyle(::Primary, ::Secondary) = Primary()\n\nwould indicate that style Primary has precedence over Secondary. You do not have to (and generally should not) define both argument orders. The result does not have to be one of the input arguments, it could be a third type.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FunctionImplementations.permuteddims-Tuple{AbstractArray, Any}","page":"Reference","title":"FunctionImplementations.permuteddims","text":"permuteddims(a::AbstractArray, perm)\n\nLazy version of permutedims. Defaults to constructing a Base.PermutedDimsArray but can be customized to output a different type of array.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FunctionImplementations.result_style","page":"Reference","title":"FunctionImplementations.result_style","text":"result_style(s1::Style[, s2::Style])::Style\n\nTakes one or two Styles and combines them using Style to determine a common Style.\n\nExamples\n\njulia> FunctionImplementations.result_style(FunctionImplementations.DefaultArrayStyle(), FunctionImplementations.DefaultArrayStyle())\nFunctionImplementations.DefaultArrayStyle()\n\njulia> FunctionImplementations.result_style(FunctionImplementations.UnknownStyle(), FunctionImplementations.DefaultArrayStyle())\nFunctionImplementations.DefaultArrayStyle()\n\n\n\n\n\n","category":"function"},{"location":"reference/#FunctionImplementations.style","page":"Reference","title":"FunctionImplementations.style","text":"style(cs...)::Style\n\nDecides which Style to use for any number of value arguments. Uses Style to get the style for each argument, and uses result_style to combine styles.\n\nExamples\n\njulia> FunctionImplementations.style([1], [1 2; 3 4])\nFunctionImplementations.DefaultArrayStyle()\n\n\n\n\n\n","category":"function"},{"location":"reference/#FunctionImplementations.zero!-Tuple{AbstractArray}","page":"Reference","title":"FunctionImplementations.zero!","text":"zero!(a::AbstractArray)\n\nIn-place version of zero(a), sets all entries of a to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FunctionImplementations.Concatenate","page":"Reference","title":"FunctionImplementations.Concatenate","text":"module Concatenate\n\nAlternative implementation for Base.cat through Concatenate.cat(!).\n\nThis is mostly a copy of the Base implementation, with the main difference being that the destination is chosen based on all inputs instead of just the first.\n\nAdditionally, we have an intermediate representation in terms of a Concatenated object, reminiscent of how Broadcast works.\n\nThe various entry points for specializing behavior are:\n\nDestination selection can be achieved through:\n\nBase.similar(concat::Concatenated{Style}, ::Type{T}, axes) where {Style}\n\nCustom implementations:\n\nBase.copy(concat::Concatenated{Style}) # custom implementation of cat\nBase.copyto!(dest, concat::Concatenated{Style}) # custom implementation of cat! based on style\nBase.copyto!(dest, concat::Concatenated{Nothing}) # custom implementation of cat! based on typeof(dest)\n\n\n\n\n\n","category":"module"},{"location":"reference/#FunctionImplementations.Concatenate.Concatenated","page":"Reference","title":"FunctionImplementations.Concatenate.Concatenated","text":"Concatenated{Style, Dims, Args <: Tuple}\n\nLazy representation of the concatenation of various Args along Dims, in order to provide hooks to customize the implementation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionImplementations.Concatenate.cat!-Tuple{Any, Vararg{Any}}","page":"Reference","title":"FunctionImplementations.Concatenate.cat!","text":"Concatenate.cat!(dest, args...; dims)\n\nConcatenate the supplied args along dimensions dims, placing the result into dest.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FunctionImplementations.Concatenate.cat-Tuple","page":"Reference","title":"FunctionImplementations.Concatenate.cat","text":"Concatenate.cat(args...; dims)\n\nConcatenate the supplied args along dimensions dims.\n\nSee also concatenate and cat!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FunctionImplementations.Concatenate.concatenate-Tuple{Any, Vararg{Any}}","page":"Reference","title":"FunctionImplementations.Concatenate.concatenate","text":"concatenate(dims, args...)\n\nConcatenate the supplied args along dimensions dims.\n\nSee also cat and cat!.\n\n\n\n\n\n","category":"method"},{"location":"#FunctionImplementations.jl","page":"Home","title":"FunctionImplementations.jl","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: code style: runic) (Image: Aqua)","category":"section"},{"location":"#Support","page":"Home","title":"Support","text":"<img class=\"display-light-only\" src=\"assets/CCQ.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n<img class=\"display-dark-only\" src=\"assets/CCQ-dark.png\" width=\"20%\" alt=\"Flatiron Center for Computational Quantum Physics logo.\"/>\n\nFunctionImplementations.jl is supported by the Flatiron Institute, a division of the Simons Foundation.","category":"section"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.\n\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\")\n\nor:\n\njulia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\")\n\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, the package can be added as usual through the package manager:\n\njulia> Pkg.add(\"FunctionImplementations\")","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"using FunctionImplementations: FunctionImplementations\n\nExamples go here.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
