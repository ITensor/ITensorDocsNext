[{"id":3,"pagetitle":"Home","title":"SparseArraysBase.jl","ref":"/ITensorDocsNext/SparseArraysBase/stable/#SparseArraysBase.jl","content":" SparseArraysBase.jl"},{"id":4,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Support","content":" Support SparseArraysBase.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":5,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"SparseArraysBase\")"},{"id":6,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Examples","content":" Examples using SparseArraysBase: SparseArrayDOK, SparseMatrixDOK, SparseVectorDOK, eachstoredindex,\n    getstoredindex, getunstoredindex, isstored, setstoredindex!, setunstoredindex!,\n    storedlength, storedpairs, storedvalues, zero!\nusing Test: @test, @test_throws\n\na = SparseArrayDOK{Float64}(undef, 2, 2) 2×2 SparseArraysBase.SparseMatrixDOK{Float64, FillArrays.Zeros{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}}:\n  ⋅    ⋅ \n  ⋅    ⋅  AbstractArray interface: @test iszero(a)\n@test iszero(sum(a))\n@test iszero(storedlength(a))\n\na[1, 2] = 12\n@test a == [0 12; 0 0]\n@test a[1, 1] == 0\n@test a[2, 1] == 0\n@test a[1, 2] == 12\n@test a[2, 2] == 0 Test Passed SparseArraysBase interface: using Dictionaries: IndexError\n@test issetequal(eachstoredindex(a), [CartesianIndex(1, 2)])\n@test getstoredindex(a, 1, 2) == 12\n@test_throws IndexError getstoredindex(a, 1, 1)\n@test getunstoredindex(a, 1, 1) == 0\n@test getunstoredindex(a, 1, 2) == 0\n@test !isstored(a, 1, 1)\n@test isstored(a, 1, 2)\n@test setstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test_throws IndexError setstoredindex!(copy(a), 21, 2, 1)\n@test_throws IndexError setunstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test storedlength(a) == 1\n@test issetequal(storedpairs(a), [CartesianIndex(1, 2) => 12])\n@test issetequal(storedvalues(a), [12])\n@test sum(a) == 12\n@test isreal(a)\n@test !iszero(a)\n@test mapreduce(x -> 2x, +, a) == 24 Test Passed AbstractArray functionality: b = a .+ 2 .* a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [0 12; 24 0]\n@test storedlength(b) == 2\n@test sum(b) == 36\n@test isreal(b)\n@test !iszero(b)\n@test mapreduce(x -> 2x, +, b) == 72\n\nb = permutedims(a, (2, 1))\n@test b isa SparseMatrixDOK{Float64}\n@test b[1, 1] == a[1, 1]\n@test b[2, 1] == a[1, 2]\n@test b[1, 2] == a[2, 1]\n@test b[2, 2] == a[2, 2]\n\nb = a * a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [144 0; 0 0]\n@test storedlength(b) == 1 Test Passed Second column. b = a[1:2, 2]\n@test b isa SparseVectorDOK{Float64}\n@test b == [12, 0]\n@test storedlength(b) == 1\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na .= 2\nfor I in eachindex(a)\n    @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 2)\nfor I in eachindex(a)\n    @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 0)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nzero!(a)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nb = zero(a)\n@test iszero(b)\n@test iszero(storedlength(b)) Test Passed This page was generated using  Literate.jl ."},{"id":9,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/SparseArraysBase/stable/reference/#Reference","content":" Reference SparseArraysBase.SparseArrayDOK  —  Type SparseArrayDOK{T,N,F} <: AbstractSparseArray{T,N} N -dimensional sparse dictionary-of-keys (DOK) array with elements of type  T , with a specified background of unstored values  unstored  of the size of the array. source SparseArraysBase.SparseArrayDOK  —  Method SparseArrayDOK{T}(undef, dims...)\nSparseArrayDOK{T,N}(undef, dims...) Construct an uninitialized  N -dimensional  SparseArrayDOK  containing elements of type  T .  N  can either be supplied explicitly, or be determined by the length or number of  dims . source SparseArraysBase.ZeroPreserving  —  Type abstract type ZeroPreserving <: Function end Holy Trait to indicate how a function interacts with abstract zero values: StrongPreserving  : output is guaranteed to be zero if  any  input is. WeakPreserving  : output is guaranteed to be zero if  all  inputs are. NonPreserving  : no guarantees on output. To attempt to automatically determine this, either  ZeroPreserving(f, A::AbstractArray...)  or  ZeroPreserving(f, T::Type...)  can be used/overloaded. Warning incorrectly registering a function to be zero-preserving will lead to silently wrong results. source SparseArraysBase.eachstoredindex  —  Function eachstoredindex(A::AbstractArray...)\neachstoredindex(style::IndexStyle, A::AbstractArray...) An iterable over all indices of the stored values. For multiple arrays, the iterable contains all indices where at least one input has a stored value. The type of indices can be controlled through  style , which will default to a compatible style for all inputs. The order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as  storedvalues . See also  storedvalues ,  storedpairs  and  storedlength . source SparseArraysBase.getstoredindex  —  Method getstoredindex(A::AbstractArray, I...) -> eltype(A) Obtain  getindex(A, I...)  with the guarantee that there is a stored entry at that location. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.getunstoredindex  —  Method getunstoredindex(A::AbstractArray, I...) -> eltype(A) Obtain the value that would be returned by  getindex(A, I...)  when there is no stored entry at that location. By default, this takes an explicit copy of the  getindex  implementation to mimick a newly instantiated object. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.isstored  —  Method isstored(A::AbstractArray, I...) -> Bool Check if the array  A  has a stored entry at the location specified by indices  I... . For generic array types this defaults to  true  whenever the indices are inbounds, but sparse array types might overload this function when appropriate. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.setstoredindex!  —  Method setstoredindex!(A::AbstractArray, v, I...) -> A setindex!(A, v, I...)  with the guarantee that there is a stored entry at the given location. Similar to  Base.setindex! , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.setunstoredindex!  —  Method setunstoredindex!(A::AbstractArray, v, I...) -> A setindex!(A, v, I...)  with the guarantee that there is no stored entry at the given location. Similar to  Base.setindex! , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.sparse  —  Method sparse(storage::Union{AbstractDict,AbstractDictionary}, dims...[; getunstored]) Construct an  N -dimensional  SparseArrayDOK  containing elements of type  T . Both  T  and  N  can either be supplied explicitly or be determined by the  storage  and the length or number of  dims . If  dims  aren't specified, the size will be determined automatically from the input indices. This constructor does not take ownership of the supplied storage, and will result in an independent container. source SparseArraysBase.sparserand  —  Function sparserand([rng], [T::Type], dims; density::Real=0.5, randfun::Function=rand) -> A::SparseArrayDOK{T} Create a random size  dims  sparse array in which the probability of any element being stored is independently given by  density . The optional  rng  argument specifies a random number generator, see also  Random . The optional  T  argument specifies the element type, which defaults to  Float64 . The optional  randfun  argument can be used to control the type of random elements, and should support the signature  randfun(rng, T, N)  to generate  N  entries of type  T . See also  sparserand! . source SparseArraysBase.sparserand!  —  Function sparserand!([rng], A::AbstractArray; density::Real=0.5, randfun::Function=rand) -> A Overwrite part of an array with random entries, where the probability of overwriting is independently given by  density . The optional  rng  argument specifies a random number generator, see also  Random . The optional  randfun  argument can be used to control the type of random elements, and should support the signature  randfun(rng, T, N)  to generate  N  entries of type  T . See also  sparserand . source SparseArraysBase.sparsezeros  —  Function sparsezeros([T::Type], dims[; getunstored]) -> A::SparseArrayDOK{T} Create an empty size  dims  sparse array. The optional  T  argument specifies the element type, which defaults to  Float64 . source SparseArraysBase.storedlength  —  Function storedlength(A::AbstractArray) -> Int The number of values that are currently being stored. source SparseArraysBase.storedpairs  —  Function storedpairs(A::AbstractArray) -> (k, v)... An iterable over all stored indices and their corresponding stored values. The indices are compatible with  IndexStyle(A) . The order of the iterable is not guaranteed to be fixed or sorted. See also  eachstoredindex  and  storedvalues . source SparseArraysBase.storedvalues  —  Function storedvalues(A::AbstractArray) -> v... An iterable over all stored values. The order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as  eachstoredindex . source"}]