[{"id":3,"pagetitle":"Home","title":"ITensorNetworksNext.jl","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#ITensorNetworksNext.jl","content":" ITensorNetworksNext.jl"},{"id":4,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#Support","content":" Support ITensorNetworksNext.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":5,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"ITensorNetworksNext\")"},{"id":6,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#Examples","content":" Examples using ITensorNetworksNext: ITensorNetworksNext Examples go here. This page was generated using  Literate.jl ."},{"id":9,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/reference/#Reference","content":" Reference ITensorNetworksNext.TensorNetworkGenerators.delta_network  —  Method delta_network(f, elt::Type = Float64, g::AbstractGraph) Construct a TensorNetwork on the graph  g  with element type  elt  that has delta tensors on each vertex. Link dimensions are defined using the function  f(e)  that should take an edge  e  as an input and should output the link index on that edge. source ITensorNetworksNext.TensorNetworkGenerators.ising_network  —  Method ising_network(f, β::Number, g::AbstractGraph) Construct a TensorNetwork on the graph  g  with inverse temperature  β  that has Ising partition function tensors on each vertex. Link dimensions are defined using the function  f(e)  that should take an edge  e  as an input and should output the link index on that edge. source"},{"id":12,"pagetitle":"Home","title":"TensorAlgebra.jl","ref":"/ITensorDocsNext/TensorAlgebra/stable/#TensorAlgebra.jl","content":" TensorAlgebra.jl"},{"id":13,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/TensorAlgebra/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"TensorAlgebra\")"},{"id":14,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/TensorAlgebra/stable/#Examples","content":" Examples using TensorAlgebra: TensorAlgebra Examples go here. This page was generated using  Literate.jl ."},{"id":17,"pagetitle":"Home","title":"SparseArraysBase.jl","ref":"/ITensorDocsNext/SparseArraysBase/stable/#SparseArraysBase.jl","content":" SparseArraysBase.jl"},{"id":18,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Support","content":" Support SparseArraysBase.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":19,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"SparseArraysBase\")"},{"id":20,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Examples","content":" Examples using SparseArraysBase: SparseArrayDOK, SparseMatrixDOK, SparseVectorDOK, eachstoredindex,\n    getstoredindex, getunstoredindex, isstored, setstoredindex!, setunstoredindex!,\n    storedlength, storedpairs, storedvalues, zero!\nusing Test: @test, @test_throws\n\na = SparseArrayDOK{Float64}(undef, 2, 2) 2×2 SparseArraysBase.SparseMatrixDOK{Float64, FillArrays.Zeros{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}}:\n  ⋅    ⋅ \n  ⋅    ⋅  AbstractArray interface: @test iszero(a)\n@test iszero(sum(a))\n@test iszero(storedlength(a))\n\na[1, 2] = 12\n@test a == [0 12; 0 0]\n@test a[1, 1] == 0\n@test a[2, 1] == 0\n@test a[1, 2] == 12\n@test a[2, 2] == 0 Test Passed SparseArraysBase interface: using Dictionaries: IndexError\n@test issetequal(eachstoredindex(a), [CartesianIndex(1, 2)])\n@test getstoredindex(a, 1, 2) == 12\n@test_throws IndexError getstoredindex(a, 1, 1)\n@test getunstoredindex(a, 1, 1) == 0\n@test getunstoredindex(a, 1, 2) == 0\n@test !isstored(a, 1, 1)\n@test isstored(a, 1, 2)\n@test setstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test_throws IndexError setstoredindex!(copy(a), 21, 2, 1)\n@test_throws IndexError setunstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test storedlength(a) == 1\n@test issetequal(storedpairs(a), [CartesianIndex(1, 2) => 12])\n@test issetequal(storedvalues(a), [12])\n@test sum(a) == 12\n@test isreal(a)\n@test !iszero(a)\n@test mapreduce(x -> 2x, +, a) == 24 Test Passed AbstractArray functionality: b = a .+ 2 .* a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [0 12; 24 0]\n@test storedlength(b) == 2\n@test sum(b) == 36\n@test isreal(b)\n@test !iszero(b)\n@test mapreduce(x -> 2x, +, b) == 72\n\nb = permutedims(a, (2, 1))\n@test b isa SparseMatrixDOK{Float64}\n@test b[1, 1] == a[1, 1]\n@test b[2, 1] == a[1, 2]\n@test b[1, 2] == a[2, 1]\n@test b[2, 2] == a[2, 2]\n\nb = a * a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [144 0; 0 0]\n@test storedlength(b) == 1 Test Passed Second column. b = a[1:2, 2]\n@test b isa SparseVectorDOK{Float64}\n@test b == [12, 0]\n@test storedlength(b) == 1\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na .= 2\nfor I in eachindex(a)\n    @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 2)\nfor I in eachindex(a)\n    @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 0)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nzero!(a)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nb = zero(a)\n@test iszero(b)\n@test iszero(storedlength(b)) Test Passed This page was generated using  Literate.jl ."},{"id":23,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/SparseArraysBase/stable/reference/#Reference","content":" Reference SparseArraysBase.SparseArrayDOK  —  Type SparseArrayDOK{T,N,F} <: AbstractSparseArray{T,N} N -dimensional sparse dictionary-of-keys (DOK) array with elements of type  T , with a specified background of unstored values  unstored  of the size of the array. source SparseArraysBase.SparseArrayDOK  —  Method SparseArrayDOK{T}(undef, dims...)\nSparseArrayDOK{T,N}(undef, dims...) Construct an uninitialized  N -dimensional  SparseArrayDOK  containing elements of type  T .  N  can either be supplied explicitly, or be determined by the length or number of  dims . source SparseArraysBase.ZeroPreserving  —  Type abstract type ZeroPreserving <: Function end Holy Trait to indicate how a function interacts with abstract zero values: StrongPreserving  : output is guaranteed to be zero if  any  input is. WeakPreserving  : output is guaranteed to be zero if  all  inputs are. NonPreserving  : no guarantees on output. To attempt to automatically determine this, either  ZeroPreserving(f, A::AbstractArray...)  or  ZeroPreserving(f, T::Type...)  can be used/overloaded. Warning incorrectly registering a function to be zero-preserving will lead to silently wrong results. source SparseArraysBase.eachstoredindex  —  Function eachstoredindex(A::AbstractArray...)\neachstoredindex(style::IndexStyle, A::AbstractArray...) An iterable over all indices of the stored values. For multiple arrays, the iterable contains all indices where at least one input has a stored value. The type of indices can be controlled through  style , which will default to a compatible style for all inputs. The order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as  storedvalues . See also  storedvalues ,  storedpairs  and  storedlength . source SparseArraysBase.getstoredindex  —  Method getstoredindex(A::AbstractArray, I...) -> eltype(A) Obtain  getindex(A, I...)  with the guarantee that there is a stored entry at that location. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.getunstoredindex  —  Method getunstoredindex(A::AbstractArray, I...) -> eltype(A) Obtain the value that would be returned by  getindex(A, I...)  when there is no stored entry at that location. By default, this takes an explicit copy of the  getindex  implementation to mimick a newly instantiated object. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.isstored  —  Method isstored(A::AbstractArray, I...) -> Bool Check if the array  A  has a stored entry at the location specified by indices  I... . For generic array types this defaults to  true  whenever the indices are inbounds, but sparse array types might overload this function when appropriate. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.setstoredindex!  —  Method setstoredindex!(A::AbstractArray, v, I...) -> A setindex!(A, v, I...)  with the guarantee that there is a stored entry at the given location. Similar to  Base.setindex! , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.setunstoredindex!  —  Method setunstoredindex!(A::AbstractArray, v, I...) -> A setindex!(A, v, I...)  with the guarantee that there is no stored entry at the given location. Similar to  Base.setindex! , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.sparse  —  Method sparse(storage::Union{AbstractDict,AbstractDictionary}, dims...[; getunstored]) Construct an  N -dimensional  SparseArrayDOK  containing elements of type  T . Both  T  and  N  can either be supplied explicitly or be determined by the  storage  and the length or number of  dims . If  dims  aren't specified, the size will be determined automatically from the input indices. This constructor does not take ownership of the supplied storage, and will result in an independent container. source SparseArraysBase.sparserand  —  Function sparserand([rng], [T::Type], dims; density::Real=0.5, randfun::Function=rand) -> A::SparseArrayDOK{T} Create a random size  dims  sparse array in which the probability of any element being stored is independently given by  density . The optional  rng  argument specifies a random number generator, see also  Random . The optional  T  argument specifies the element type, which defaults to  Float64 . The optional  randfun  argument can be used to control the type of random elements, and should support the signature  randfun(rng, T, N)  to generate  N  entries of type  T . See also  sparserand! . source SparseArraysBase.sparserand!  —  Function sparserand!([rng], A::AbstractArray; density::Real=0.5, randfun::Function=rand) -> A Overwrite part of an array with random entries, where the probability of overwriting is independently given by  density . The optional  rng  argument specifies a random number generator, see also  Random . The optional  randfun  argument can be used to control the type of random elements, and should support the signature  randfun(rng, T, N)  to generate  N  entries of type  T . See also  sparserand . source SparseArraysBase.sparsezeros  —  Function sparsezeros([T::Type], dims[; getunstored]) -> A::SparseArrayDOK{T} Create an empty size  dims  sparse array. The optional  T  argument specifies the element type, which defaults to  Float64 . source SparseArraysBase.storedlength  —  Function storedlength(A::AbstractArray) -> Int The number of values that are currently being stored. source SparseArraysBase.storedpairs  —  Function storedpairs(A::AbstractArray) -> (k, v)... An iterable over all stored indices and their corresponding stored values. The indices are compatible with  IndexStyle(A) . The order of the iterable is not guaranteed to be fixed or sorted. See also  eachstoredindex  and  storedvalues . source SparseArraysBase.storedvalues  —  Function storedvalues(A::AbstractArray) -> v... An iterable over all stored values. The order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as  eachstoredindex . source"},{"id":26,"pagetitle":"Home","title":"GradedArrays.jl","ref":"/ITensorDocsNext/GradedArrays/stable/#GradedArrays.jl","content":" GradedArrays.jl"},{"id":27,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/GradedArrays/stable/#Support","content":" Support GradedArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":28,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/GradedArrays/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"GradedArrays\")"},{"id":29,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/GradedArrays/stable/#Examples","content":" Examples using GradedArrays: GradedArrays Examples go here. This page was generated using  Literate.jl ."},{"id":32,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/GradedArrays/stable/reference/#Reference","content":" Reference GradedArrays.GradedOneTo  —  Type const GradedOneTo{I, R1, R2} = BlockOneTo{Int, Vector{SectorUnitRange{I, R1, R2}}, Vector{Int}} See also  SectorUnitRange  and  GradedUnitRange . source GradedArrays.GradedUnitRange  —  Type const GradedUnitRange{I, R1, R2} = BlockUnitRange{Int, Vector{SectorUnitRange{I, R1, R2}}, Vector{Int}} Type alias for the axis type of graded arrays. This represents the blocked combination of ranges, where each block is a  SectorUnitRange  with sector labels of type  I  and underlying range types  R1  and  R2 . See also  SectorUnitRange  and  GradedOneTo . source GradedArrays.SectorArray  —  Type SectorArray(sectors, data) <: AbstractKroneckerArray A representation of a general symmetric array as the combination of a structural part ( sectors ) and a data part ( data ). This can be thought of as a direct implementation of the Wigner-Eckart theorem. source GradedArrays.SectorDelta  —  Type SectorDelta{T}(sectors::NTuple{N, I}) <: AbstractArray{T, N} An immutable representation of the structural tensor associated to the representation space of a number of sectors. For abelian symmetries, this boils down to a scalar which can always be normalized to 1. source GradedArrays.SectorOneTo  —  Type const SectorOneTo{I <: SectorRange} = SectorUnitRange{I, Base.OneTo{Int}, Base.OneTo{Int}} source GradedArrays.SectorRange  —  Type SectorRange(sector::TKS.Sector, isdual::Bool) Unit range with elements of type  Int  that additionally stores a sector to denote the grading. Equivalent to  Base.OneTo(length(sector)) . Additionally holds a flag to denote the duality. source GradedArrays.SectorUnitRange  —  Type const SectorUnitRange{I <: SectorRange, RB <: AbstractUnitRange{Int}, R <: AbstractUnitRange{Int}} =\n    CartesianProductUnitRange{Int, I, RB, R} Type alias for the cartesian product of a sector range of type  I , and a unit range of type  RB , which yields a total range of type  R . source GradedArrays.flux  —  Function flux(a::AbstractArray)\nflux(a::AbstractArray, I::Block...) Compute the total flux of an  AbstractArray , defined as the fusion of all of the incoming charges, or the flux associated to a provided block. Whenever the flux cannot be meaningfully computed, for example for non-graded arrays, or empty ones, this function returns  UndefinedFlux . source GradedArrays.gradedrange  —  Method gradedrange(xs::AbstractVector{<:Pair}) Construct a graded range from the provided list of  sector => range  pairs. source GradedArrays.sectorrange  —  Function sectorrange(sector, range)\nsectorrange(sector, dim) Construct a  SectorUnitRange  for the given sector and dimension or range. source"},{"id":35,"pagetitle":"Home","title":"FunctionImplementations.jl","ref":"/ITensorDocsNext/FunctionImplementations/stable/#FunctionImplementations.jl","content":" FunctionImplementations.jl"},{"id":36,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/FunctionImplementations/stable/#Support","content":" Support FunctionImplementations.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":37,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/FunctionImplementations/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"FunctionImplementations\")"},{"id":38,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/FunctionImplementations/stable/#Examples","content":" Examples using FunctionImplementations: FunctionImplementations Examples go here. This page was generated using  Literate.jl ."},{"id":41,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/FunctionImplementations/stable/reference/#Reference","content":" Reference FunctionImplementations.AbstractArrayImplementationStyle  —  Type FunctionImplementations.AbstractArrayImplementationStyle <: ImplementationStyle  is the abstract supertype for any style associated with an  AbstractArray  type. Note that if two or more  AbstractArrayImplementationStyle  subtypes conflict, the resulting style will fall back to that of  Array s. If this is undesirable, you may need to define binary  ImplementationStyle  rules to control the output type. See also  FunctionImplementations.DefaultArrayImplementationStyle . source FunctionImplementations.DefaultArrayImplementationStyle  —  Type FunctionImplementations.DefaultArrayImplementationStyle()  is a  FunctionImplementations.ImplementationStyle  indicating that an object behaves as an array. Specifically,  DefaultArrayImplementationStyle  is used for any  AbstractArray  type that hasn't defined a specialized style, and in the absence of overrides from other arguments the resulting output type is  Array . source FunctionImplementations.Implementation  —  Type FunctionImplementations.Implementation(f, s)  wraps a function  f  with a style  s . This can be used to create function implementations that behave differently based on the style of their arguments. source FunctionImplementations.ImplementationStyle  —  Type ImplementationStyle  is an abstract type and trait-function used to determine behavior of objects.  ImplementationStyle(typeof(x))  returns the style associated with  x . To customize the behavior of a type, one can declare a style by defining a type/method pair struct MyContainerImplementationStyle <: ImplementationStyle end\nFunctionImplementations.ImplementationStyle(::Type{<:MyContainer}) = MyContainerImplementationStyle() source FunctionImplementations.ImplementationStyle  —  Method (s::ImplementationStyle)(f) Calling a ImplementationStyle  s  with a function  f  as  s(f)  is a shorthand for creating a  FunctionImplementations.Implementation  object wrapping the function  f  with ImplementationStyle  s . source FunctionImplementations.ImplementationStyle  —  Method ImplementationStyle(::ImplementationStyle1, ::ImplementationStyle2) = ImplementationStyle3() Indicate how to resolve different  ImplementationStyle s. For example, ImplementationStyle(::Primary, ::Secondary) = Primary() would indicate that style  Primary  has precedence over  Secondary . You do not have to (and generally should not) define both argument orders. The result does not have to be one of the input arguments, it could be a third type. source FunctionImplementations.permuteddims  —  Method permuteddims(a::AbstractArray, perm) Lazy version of  permutedims . Defaults to constructing a  Base.PermutedDimsArray  but can be customized to output a different type of array. source FunctionImplementations.result_style  —  Function result_style(s1::ImplementationStyle[, s2::ImplementationStyle])::ImplementationStyle Takes one or two  ImplementationStyle s and combines them using  ImplementationStyle  to determine a common  ImplementationStyle . Examples julia> FunctionImplementations.result_style(\n           FunctionImplementations.DefaultArrayImplementationStyle(),\n           FunctionImplementations.DefaultArrayImplementationStyle()\n       )\nFunctionImplementations.DefaultArrayImplementationStyle()\n\njulia> FunctionImplementations.result_style(\n           FunctionImplementations.UnknownImplementationStyle(),\n           FunctionImplementations.DefaultArrayImplementationStyle()\n       )\nFunctionImplementations.DefaultArrayImplementationStyle() source FunctionImplementations.style  —  Function style(cs...)::ImplementationStyle Decides which  ImplementationStyle  to use for any number of value arguments. Uses  ImplementationStyle  to get the style for each argument, and uses  result_style  to combine styles. Examples julia> FunctionImplementations.style([1], [1 2; 3 4])\nFunctionImplementations.DefaultArrayImplementationStyle() source FunctionImplementations.zero!  —  Method zero!(a::AbstractArray) In-place version of  zero(a) , sets all entries of  a  to zero. source FunctionImplementations.Concatenate  —  Module module Concatenate Alternative implementation for  Base.cat  through  Concatenate.cat(!) . This is mostly a copy of the Base implementation, with the main difference being that the destination is chosen based on all inputs instead of just the first. Additionally, we have an intermediate representation in terms of a Concatenated object, reminiscent of how Broadcast works. The various entry points for specializing behavior are: Destination selection can be achieved through: Base.similar(concat::Concatenated{Style}, ::Type{T}, axes) where {Style} Custom implementations: Base.copy(concat::Concatenated{Style}) # custom implementation of cat\nBase.copyto!(dest, concat::Concatenated{Style}) # custom implementation of cat! based on style\nBase.copyto!(dest, concat::Concatenated{Nothing}) # custom implementation of cat! based on typeof(dest) source FunctionImplementations.Concatenate.Concatenated  —  Type Concatenated{Style, Dims, Args <: Tuple} Lazy representation of the concatenation of various  Args  along  Dims , in order to provide hooks to customize the implementation. source FunctionImplementations.Concatenate.cat!  —  Method Concatenate.cat!(dest, args...; dims) Concatenate the supplied  args  along dimensions  dims , placing the result into  dest . source FunctionImplementations.Concatenate.cat  —  Method Concatenate.cat(args...; dims) Concatenate the supplied  args  along dimensions  dims . See also  concatenate  and  cat! . source FunctionImplementations.Concatenate.concatenate  —  Method concatenate(dims, args...) Concatenate the supplied  args  along dimensions  dims . See also  cat  and  cat! . source"},{"id":44,"pagetitle":"Home","title":"TypeParameterAccessors.jl","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/#TypeParameterAccessors.jl","content":" TypeParameterAccessors.jl"},{"id":45,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"TypeParameterAccessors\")"},{"id":46,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/#Examples","content":" Examples using Test: @test\nusing TypeParameterAccessors Get type parameters: @test type_parameters(Array{Float64}, 1) == Float64\n@test type_parameters(Matrix{Float64}, 2) == 2\n@test type_parameters(Matrix{Float64}) == (Float64, 2)\n@test type_parameters(Array{Float64}, eltype) == Float64\n@test type_parameters(Matrix{Float64}, ndims) == 2\n@test type_parameters(Matrix{Float64}, (eltype, ndims)) == (Float64, 2) Test Passed Set type parameters: @test set_type_parameters(Array, 1, Float32) == Array{Float32}\n@test set_type_parameters(Array, (1,), (Float32,)) == Array{Float32}\n@test set_type_parameters(Array, (1, 2), (Float32, 2)) == Matrix{Float32}\n@test set_type_parameters(Array, (eltype,), (Float32,)) == Array{Float32}\n@test set_type_parameters(Array, (eltype, ndims), (Float32, 2)) == Matrix{Float32} Test Passed Specify type parameters: @test specify_type_parameters(Array{Float64}, (eltype, ndims), (Float32, 2)) ==\n  Matrix{Float64}\n@test specify_type_parameters(Array{Float64}, ndims, 2) == Matrix{Float64}\n@test specify_type_parameters(Array{Float64}, eltype, Float32) == Array{Float64} Test Passed Unspecify type parameters: @test unspecify_type_parameters(Matrix{Float32}) == Array\n@test unspecify_type_parameters(Matrix{Float32}, 1) == Matrix\n@test unspecify_type_parameters(Matrix{Float32}, (eltype,)) == Matrix\n@test unspecify_type_parameters(Matrix{Float32}, (ndims,)) == Array{Float32} Test Passed Getting default type parameters @test default_type_parameters(Array) == (Float64, 1)\n@test default_type_parameters(Array, eltype) == Float64\n@test default_type_parameters(Array, 2) == 1\n@test default_type_parameters(Array, (eltype, ndims)) == (Float64, 1) Test Passed Set default type parameters: @test set_default_type_parameters(Array) == Vector{Float64}\n@test set_default_type_parameters(Array, (eltype,)) == Array{Float64}\n@test set_default_type_parameters(Array, 2) == Vector Test Passed Specify default type parameters: @test specify_default_type_parameters(Matrix, (eltype, ndims)) == Matrix{Float64}\n@test specify_default_type_parameters(Matrix, eltype) == Matrix{Float64}\n@test specify_default_type_parameters(Array{Float32}, (eltype, ndims)) == Vector{Float32} Test Passed Other functionality: parenttype unwrap_array_type is_wrapped_array set_eltype set_ndims set_parenttype similartype This page was generated using  Literate.jl ."},{"id":49,"pagetitle":"Library","title":"Index","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Index","content":" Index Docstrings for the  TypeParameterAccessors.jl  public API."},{"id":50,"pagetitle":"Library","title":"Contents","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Contents","content":" Contents Contents Index Type parameter interface Array -type tools"},{"id":51,"pagetitle":"Library","title":"Index","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Index-2","content":" Index TypeParameterAccessors.Position TypeParameterAccessors.default_type_parameters TypeParameterAccessors.get_type_parameters TypeParameterAccessors.is_parameter_specified TypeParameterAccessors.nparameters TypeParameterAccessors.position TypeParameterAccessors.set_default_type_parameters TypeParameterAccessors.set_type_parameters TypeParameterAccessors.specify_default_type_parameters TypeParameterAccessors.specify_type_parameters TypeParameterAccessors.type_parameters TypeParameterAccessors.unspecify_type_parameters"},{"id":52,"pagetitle":"Library","title":"Type parameter interface","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Type-parameter-interface","content":" Type parameter interface TypeParameterAccessors.position  —  Function position(type::Type, position_name)::Position An optional interface function. Defining this allows accessing a parameter at the defined position using the  position_name . For example, defining  TypeParameterAccessors.position(::Type{<:MyType}, ::typeof(eltype)) = Position(1)  allows accessing the first type parameter with  type_parameters(MyType(...), eltype) , in addition to the standard  type_parameters(MyType(...), 1)  or  type_parameters(MyType(...), Position(1)) . source TypeParameterAccessors.Position  —  Type struct Position{P} end Singleton type to statically represent the type-parameter position. This is meant for internal use as a  Val -like structure to improve type-inference. source TypeParameterAccessors.type_parameters  —  Function type parameters(type or_obj, [pos]) Return a tuple containing the type parameters of a given type or object. Optionally you can specify a position to just get the parameter for that position, or a tuple of positions to get a subset of parameters. Errors if parameters are unspecified. For an unchecked version, see  get_type_parameters . source TypeParameterAccessors.get_type_parameters  —  Function get type parameters(type or obj, [pos]) Return a tuple containing the type parameters of a given type or object. Optionally you can specify a position to just get the parameter for that position, or a tuple of positions to get a subset of parameters. If parameters are unspecified, returns a  TypeVar . For a checked version, see  type_parameters . source TypeParameterAccessors.default_type_parameters  —  Function default type parameters(type::Type)::Tuple An optional interface function. Defining this allows filling type parameters of the specified type with default values. This function should output a Tuple of the default values, with exactly one for each type parameter slot of the type. source TypeParameterAccessors.nparameters  —  Function nparameters(type or obj) Return the number of type parameters for a given type or object. source TypeParameterAccessors.is_parameter_specified  —  Function is parameter specified(type::Type, pos) Return whether or not the type parameter at a given position is considered specified. source TypeParameterAccessors.unspecify_type_parameters  —  Function unspecify type parameters(type::Type, [positions::Tuple])   unspecify type parameters(type::Type, position) Return a new type where the type parameters at the given positions are unset. source TypeParameterAccessors.set_type_parameters  —  Function set type parameters(type::Type, positions::Tuple, parameters::Tuple)   set type parameters(type::Type, position, parameter) Return a new type where the type parameters at the given positions are set to the provided values. source TypeParameterAccessors.set_default_type_parameters  —  Function set default type parameters(type::Type, [positions::Tuple])   set default type parameters(type::Type, position) Set the type parameters at the given positions to their default values. source TypeParameterAccessors.specify_type_parameters  —  Function specify type parameters(type::Type, positions::Tuple, parameters::Tuple)   specify type parameters(type::Type, position, parameter) Return a new type where the type parameters at the given positions are set to the provided values, only if they were previously unspecified. source TypeParameterAccessors.specify_default_type_parameters  —  Function specify default type parameters(type::Type, [positions::Tuple])   specify default type parameters(type::Type, position) Set the type parameters at the given positions to their default values, if they had not been specified. source"},{"id":53,"pagetitle":"Library","title":"Array-type tools","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Array-type-tools","content":" Array -type tools"},{"id":56,"pagetitle":"Type parameters","title":"Type interface","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Type-interface","content":" Type interface The low-level interface of this package is centered around the ability to  get ,  set  and  specify  the type parameters of a given type."},{"id":57,"pagetitle":"Type parameters","title":"Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Type-Parameters","content":" Type Parameters The central concept in this package is a type parameter, which refers to the variables  A, B, ...  in type definitions: abstract type Foo{A,B,C,D} end\nstruct Bar{A,B,C,D} end In order to retrieve these parameters,  type_parameters  can be used, either to retrieve all parameters, or a single one: julia> type_parameters(Foo{1,2,3,4}) (1, 2, 3, 4) julia> type_parameters(Foo{1,2,3,4}, 2) 2 julia> type_parameters(Bar{:A,Int,2,Foo}) (:A, Int64, 2, Main.Foo) julia> type_parameters(Bar{:A,Int,2,Foo}, 4) Main.Foo Warning For consistency reasons, as well as due to the type system in Julia, these positions will always refer to the  base type . This means in particular that using positional type parameters in combination with type aliases can lead to unexpected results. For example,  const Foo_alias{D,C,B,A} = Foo{A,B,C,D}  would still have  type_parameters(Foo_alias) == (A, B, C, D) . In order to effectively pass on the information about  which  type parameter we want to manipulate, it can often be convenient to refer to type parameters not by their position, but rather by their meaning. In particular, this allows users to write more generic code, since the positions of type parameters have no special meaning in the Julia type system. Additionally, this avoids the unexpected results caused by type aliases. Often, these parameters have an associated function to retrieve them, such as  eltype  or  ndims . Therefore, the following syntax is also supported (and in general preferred): julia> type_parameters(Array{Int,2}, ndims) 2 julia> type_parameters(Vector{Float64}, eltype) Float64 This can not automatically be inferred for custom types however: julia> type_parameters(Bar{1}, ndims) # errors because `ndims` is not registered ERROR: MethodError: no method matching position(::Type{Main.Bar{1}}, ::typeof(ndims))\nThis error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.\n\nClosest candidates are:\n  position(::Type, ::Any)\n    @   TypeParameterAccessors   ~/work/TypeParameterAccessors.jl/TypeParameterAccessors.jl/src/ type_parameters.jl:30 \n  position(::Any, ::Any)\n    @   TypeParameterAccessors   ~/work/TypeParameterAccessors.jl/TypeParameterAccessors.jl/src/ type_parameters.jl:27 \n  position( ::Type{<:Array} , ::typeof(ndims))\n    @   TypeParameterAccessors   ~/work/TypeParameterAccessors.jl/TypeParameterAccessors.jl/src/base/ array.jl:2 \n  ... In order to support this, we internally pass everything through  position , which can be used to bind functions to positions. For type stability reasons, it is beneficial to return the static  TypeParameterAccessors.Position  instead of a regular integer. julia> TypeParameterAccessors.position(::Type{<:Bar}, ::typeof(ndims)) = TypeParameterAccessors.Position(1) julia> type_parameters(Bar{1}, ndims) 1 Warning While it might be tempting to define such functions for abstract types, this is in general not a good practice. The reason for this is again that the position of a specific type parameter is not something that is inherited by subtypes, which may decide to change the number as well as the order of the type parameters."},{"id":58,"pagetitle":"Type parameters","title":"Setting Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Setting-Type-Parameters","content":" Setting Type Parameters In a similar manner, it is also possible to alter the type parameters of a given type. That functionality is provided by  set_type_parameters : julia> set_type_parameters(Foo{1,2,3}, 4, :four) Main.Foo{1, 2, 3, :four} julia> set_type_parameters(Foo{1,2,3,4}, (1,3), (:A, :B)) Main.Foo{:A, 2, :B, 4}"},{"id":59,"pagetitle":"Type parameters","title":"Specifying and Unspecifying Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Specifying-and-Unspecifying-Type-Parameters","content":" Specifying and Unspecifying Type Parameters Finally, sometimes it is either required or useful to work with  UnionAll  types. These have type parameters that are either not specified or only bounded. For example,  Foo  is really a shorthand form of  Foo{A,B,C,D} where {A,B,C,D} . Starting from a  specified  type, you can go back to the unspecified form by unspecifying either some or all of the type parameters through  unspecify_type_parameters . julia> unspecify_type_parameters(Foo{1,2,3,4}) Main.Foo julia> unspecify_type_parameters(Foo{1,2,3,4}, 1) Main.Foo{A, 2, 3, 4} where A julia> unspecify_type_parameters(Foo{1,2,3,4}, (1, 3)) Main.Foo{A, 2, C, 4} where {A, C} Similarly, it is possible to set type parameters that have not been fully specified through  specify_type_parameters . julia> specify_type_parameter(Foo{1,2,3}, 4, 4) ERROR: UndefVarError: `specify_type_parameter` not defined in `Main`\nSuggestion: check for spelling errors or missing imports. julia> specify_type_parameters(Foo, (1, 2), (:A, Int)) Main.Foo{:A, Int64} Note that this function differs from  set_type_parameters  only by ignoring type parameters that have not been specified: julia> set_type_parameters(Foo{1,2,3}, (1, 4), (Int, Int)) Main.Foo{Int64, 2, 3, Int64} julia> specify_type_parameters(Foo{1,2,3}, (1, 4), (Int, Int)) Main.Foo{1, 2, 3, Int64}"},{"id":60,"pagetitle":"Type parameters","title":"Default Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Default-Type-Parameters","content":" Default Type Parameters Finally, it can sometimes be convenient to have default values for type parameters. This can be achieved by registering the default values through  default_type_parameters , and then setting or specifying them through  set_default_type_parameters  and  specify_default_type_parameters . julia> TypeParameterAccessors.default_type_parameters(::Type{<:Bar}) = (1, 2, 3, 4) julia> set_default_type_parameters(Bar) Main.Bar{1, 2, 3, 4} julia> specify_default_type_parameters(Bar{1,2}, (3, 4)) Main.Bar{1, 2, 3, 4}"},{"id":63,"pagetitle":"Home","title":"BackendSelection.jl","ref":"/ITensorDocsNext/BackendSelection/stable/#BackendSelection.jl","content":" BackendSelection.jl"},{"id":64,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/BackendSelection/stable/#Support","content":" Support BackendSelection.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":65,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/BackendSelection/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"BackendSelection\")"},{"id":66,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/BackendSelection/stable/#Examples","content":" Examples using BackendSelection: BackendSelection Examples go here. This page was generated using  Literate.jl ."},{"id":69,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/BackendSelection/stable/reference/#Reference","content":" Reference BackendSelection.Algorithm  —  Type BackendSelection.Algorithm A type representing a backend for a function. For example, a function might have multiple backends implementations, which internally are selected with a  BackendSelection.Algorithm  type. This allows users to extend functionality with a new implementation but use the same interface. source BackendSelection.Backend  —  Type BackendSelection.Backend A type representing a backend for a function. For example, a function might have multiple backends implementations, which internally are selected with a  BackendSelection.Backend  type. This allows users to extend functionality with a new implementation but use the same interface. source BackendSelection.@Algorithm_str  —  Macro @Algorithm_str A convenience macro for writing  Algorithm  types, typically used when adding methods to a function that supports multiple backends. source BackendSelection.@Backend_str  —  Macro @Backend_str A convenience macro for writing  Backend  types, typically used when adding methods to a function that supports multiple backends. source"}]