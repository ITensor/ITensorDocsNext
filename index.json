[{"id":3,"pagetitle":"Home","title":"ITensorNetworksNext.jl","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#ITensorNetworksNext.jl","content":" ITensorNetworksNext.jl"},{"id":4,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#Support","content":" Support ITensorNetworksNext.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":5,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"ITensorNetworksNext\")"},{"id":6,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/#Examples","content":" Examples using ITensorNetworksNext: ITensorNetworksNext Examples go here. This page was generated using  Literate.jl ."},{"id":9,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/ITensorNetworksNext/stable/reference/#Reference","content":" Reference ITensorNetworksNext.TensorNetworkGenerators.delta_network  —  Method delta_network(f, elt::Type = Float64, g::AbstractGraph) Construct a TensorNetwork on the graph  g  with element type  elt  that has delta tensors on each vertex. Link dimensions are defined using the function  f(e)  that should take an edge  e  as an input and should output the link index on that edge. source ITensorNetworksNext.TensorNetworkGenerators.ising_network  —  Method ising_network(f, β::Number, g::AbstractGraph) Construct a TensorNetwork on the graph  g  with inverse temperature  β  that has Ising partition function tensors on each vertex. Link dimensions are defined using the function  f(e)  that should take an edge  e  as an input and should output the link index on that edge. source"},{"id":12,"pagetitle":"Home","title":"ITensorBase.jl","ref":"/ITensorDocsNext/ITensorBase/stable/#ITensorBase.jl","content":" ITensorBase.jl"},{"id":13,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/ITensorBase/stable/#Support","content":" Support ITensorBase.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":14,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/ITensorBase/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"ITensorBase\")"},{"id":15,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/ITensorBase/stable/#Examples","content":" Examples using ITensorBase: ITensorBase, ITensor, Index\nusing LinearAlgebra: qr\nusing NamedDimsArrays: aligndims, dename\nusing Test: @test\ni = Index(2)\nj = Index(2)\nk = Index(2)\na = randn(i, j)\n@test a[j[2], i[1]] == a[1, 2]\n@test a[j => 2, i => 1] == a[1, 2]\na′ = randn(j, i)\nb = randn(j, k)\nc = a * b\n@test dename(c, (i, k)) ≈ dename(a, (i, j)) * dename(b, (j, k))\nd = a + a′\n@test dename(d, (i, j)) ≈ dename(a, (i, j)) + dename(a′, (i, j))\n@test a ≈ aligndims(a, (j, i))\nq, r = qr(a, (i,))\n@test q * r ≈ a Test Passed This page was generated using  Literate.jl ."},{"id":18,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/ITensorBase/stable/reference/#Reference","content":" Reference"},{"id":21,"pagetitle":"Home","title":"NamedDimsArrays.jl","ref":"/ITensorDocsNext/NamedDimsArrays/stable/#NamedDimsArrays.jl","content":" NamedDimsArrays.jl"},{"id":22,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/NamedDimsArrays/stable/#Support","content":" Support NamedDimsArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":23,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/NamedDimsArrays/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"NamedDimsArrays\")"},{"id":24,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/NamedDimsArrays/stable/#Examples","content":" Examples using NamedDimsArrays: aligndims, dename, dimnames, inds, named, namedoneto\nusing TensorAlgebra: contract\nusing Test: @test\n\n# Named dimensions\ni = namedoneto(2, \"i\")\nj = namedoneto(2, \"j\")\nk = namedoneto(2, \"k\")\n\n# Arrays with named dimensions\na1 = randn(i, j)\na2 = randn(j, k)\n\n@test dimnames(a1) == (\"i\", \"j\")\n@test inds(a1) == (i, j)\n@test axes(a1, 1) == named(1:2, \"i\")\n@test axes(a1, 2) == named(1:2, \"j\")\n@test size(a1, 1) == named(2, \"i\")\n@test size(a1, 2) == named(2, \"j\")\n\n# Indexing\n@test a1[j => 2, i => 1] == a1[1, 2]\n@test a1[j[2], i[1]] == a1[1, 2]\n\n# Tensor contraction\na_dest = a1 * a2\n\n@test issetequal(inds(a_dest), (i, k))\n# `dename` removes the names and returns an `Array`\n@test dename(a_dest, (i, k)) ≈ dename(a1, (i, j)) * dename(a2, (j, k))\n\n# Permute dimensions (like `ITensors.permute`)\na1′ = aligndims(a1, (j, i))\n@test a1′[i => 1, j => 2] == a1[i => 1, j => 2]\n@test a1′[i[1], j[2]] == a1[i[1], j[2]]\n\n# Contiguous slicing\nb1 = a1[i => 1:2, j => 1:1]\n@test b1 == a1[i[1:2], j[1:1]]\n\nb2 = a2[j => 1:1, k => 1:2]\n@test b2 == a2[j[1:1], k[1:2]]\n\n@test inds(b1) == (i[1:2], j[1:1])\n@test inds(b2) == (j[1:1], k[1:2])\n\nb_dest = b1 * b2\n\n@test issetequal(inds(b_dest), (i, k))\n\n# Non-contiguous slicing\nc1 = a1[i[[2, 1]], j[[2, 1]]]\n@test inds(c1) == (i, j)\n@test dename(c1, (i, j)) == dename(a1, (i, j))[[2, 1], [2, 1]]\n@test c1[i[1], j[2]] == a1[i[2], j[1]]\n@test c1[2, 1] == a1[1, 2]\n\na1[i[[2, 1]], j[[2, 1]]] = [22 21; 12 11]\n@test a1[i[1], j[1]] == 11\n\nx = randn(i[Base.OneTo(2)], j[Base.OneTo(1)])\na1[i[1:2], j[2:2]] = x\n@test a1[i[1], j[2]] == x[i[1], j[1]] Test Passed This page was generated using  Literate.jl ."},{"id":27,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/NamedDimsArrays/stable/reference/#Reference","content":" Reference NamedDimsArrays.nameddims  —  Method nameddims(a::AbstractArray, inds) Construct a named dimensions array from an denamed array  a  and named dimensions  inds . source NamedDimsArrays.@names  —  Macro @names x y ...\n@names x[1:3] y[1:3, 2:4] ... Short-hand notation for constructing \"named symbols\", i.e. objects that can be used as names. In other words, the following expressions are equivalent: x, y, z = @names x y z\nx, y, z = Name.((:x, :y, :z)) source"},{"id":30,"pagetitle":"Home","title":"TensorAlgebra.jl","ref":"/ITensorDocsNext/TensorAlgebra/stable/#TensorAlgebra.jl","content":" TensorAlgebra.jl"},{"id":31,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/TensorAlgebra/stable/#Support","content":" Support TensorAlgebra.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":32,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/TensorAlgebra/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"TensorAlgebra\")"},{"id":33,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/TensorAlgebra/stable/#Examples","content":" Examples using TensorAlgebra: TensorAlgebra Examples go here. This page was generated using  Literate.jl ."},{"id":36,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/TensorAlgebra/stable/reference/#Reference","content":" Reference TensorAlgebra.add!  —  Method add!(dest, src, α, β) Equivalent to  dest .= β .* dest .+ α .* src , but maybe with a more optimized/specialized implementation. source TensorAlgebra.add!  —  Method add!(dest, src) Equivalent to  dest .+= src , but maybe with a more optimized/specialized implementation. Generally calls  add!(dest, src, true, true) . source TensorAlgebra.eigen  —  Function eigen(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> D, V\neigen(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> D, V\neigen(A::AbstractArray, ndims_codomain::Val; kwargs...) -> D, V\neigen(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> D, V Compute the eigenvalue decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments ishermitian::Bool : specify if the matrix is Hermitian, which can be used to speed up the computation. If  false , the output  eltype  will always be  <:Complex . trunc : Truncation keywords for  eig(h)_trunc . Other keywords are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.eig_full! ,  MatrixAlgebraKit.eig_trunc! ,  MatrixAlgebraKit.eig_vals! ,  MatrixAlgebraKit.eigh_full! ,  MatrixAlgebraKit.eigh_trunc! , and  MatrixAlgebraKit.eigh_vals! . source TensorAlgebra.eigvals  —  Function eigvals(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> D\neigvals(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> D\neigvals(A::AbstractArray, ndims_codomain::Val; kwargs...) -> D\neigvals(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> D Compute the eigenvalues of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output is a vector of eigenvalues. Keyword arguments ishermitian::Bool : specify if the matrix is Hermitian, which can be used to speed up the computation. If  false , the output  eltype  will always be  <:Complex . Other keywords are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.eig_vals!  and  MatrixAlgebraKit.eigh_vals! . source TensorAlgebra.factorize  —  Function factorize(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> X, Y\nfactorize(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> X, Y\nfactorize(A::AbstractArray, ndims_codomain::Val; kwargs...) -> X, Y\nfactorize(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> X, Y Compute the decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments orth::Symbol=:left : specify the orthogonality of the decomposition. Currently only  :left  and  :right  are supported. Other keywords are passed on directly to MatrixAlgebraKit. source TensorAlgebra.left_null  —  Function left_null(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> N\nleft_null(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> N\nleft_null(A::AbstractArray, ndims_codomain::Val; kwargs...) -> N\nleft_null(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> N Compute the left nullspace of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output satisfies  N' * A ≈ 0  and  N' * N ≈ I . Keyword arguments atol::Real=0 : absolute tolerance for the nullspace computation. rtol::Real=0 : relative tolerance for the nullspace computation. kind::Symbol : specify the kind of decomposition used to compute the nullspace. The options are  :qr ,  :qrpos  and  :svd . The former two require  0 == atol == rtol . The default is  :qrpos  if  atol == rtol == 0 , and  :svd  otherwise. source TensorAlgebra.left_orth  —  Function left_orth(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> V, C\nleft_orth(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> V, C\nleft_orth(A::AbstractArray, ndims_codomain::Val; kwargs...) -> V, C\nleft_orth(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> V, C Compute the left orthogonal decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments Keyword arguments are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.left_orth! . source TensorAlgebra.left_polar  —  Function left_polar(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> W, P\nleft_polar(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> W, P\nleft_polar(A::AbstractArray, ndims_codomain::Val; kwargs...) -> W, P\nleft_polar(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> W, P Compute the left polar decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments Keyword arguments are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.left_polar! . source TensorAlgebra.lq  —  Function lq(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> L, Q\nlq(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> L, Q\nlq(A::AbstractArray, ndims_codomain::Val; kwargs...) -> L, Q\nlq(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> L, Q Compute the LQ decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments full::Bool=false : select between a \"full\" or a \"compact\" decomposition, where  Q  is unitary or  L  is square, respectively. positive::Bool=false : specify if the diagonal of  L  should be positive, leading to a unique decomposition. Other keywords are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.lq_full!  and  MatrixAlgebraKit.lq_compact! . source TensorAlgebra.permutedimsadd!  —  Method permutedimsadd!(dest, src, perm, α, β) dest = β * dest + α * permutedims(src, perm) . source TensorAlgebra.qr  —  Function qr(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> Q, R\nqr(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> Q, R\nqr(A::AbstractArray, ndims_codomain::Val; kwargs...) -> Q, R\nqr(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> Q, R Compute the QR decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments full::Bool=false : select between a \"full\" or a \"compact\" decomposition, where  Q  is unitary or  R  is square, respectively. positive::Bool=false : specify if the diagonal of  R  should be positive, leading to a unique decomposition. Other keywords are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.qr_full!  and  MatrixAlgebraKit.qr_compact! . source TensorAlgebra.right_null  —  Function right_null(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, ndims_codomain::Val::Val; kwargs...) -> Nᴴ\nright_null(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> Nᴴ Compute the right nullspace of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output satisfies  A * Nᴴ' ≈ 0  and  Nᴴ * Nᴴ' ≈ I . Keyword arguments atol::Real=0 : absolute tolerance for the nullspace computation. rtol::Real=0 : relative tolerance for the nullspace computation. kind::Symbol : specify the kind of decomposition used to compute the nullspace. The options are  :lq ,  :lqpos  and  :svd . The former two require  0 == atol == rtol . The default is  :lqpos  if  atol == rtol == 0 , and  :svd  otherwise. source TensorAlgebra.right_orth  —  Function right_orth(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> C, V\nright_orth(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> C, V\nright_orth(A::AbstractArray, ndims_codomain::Val; kwargs...) -> C, V\nright_orth(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> C, V Compute the right orthogonal decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments Keyword arguments are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.right_orth! . source TensorAlgebra.right_polar  —  Function right_polar(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> P, W\nright_polar(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> P, W\nright_polar(A::AbstractArray, ndims_codomain::Val; kwargs...) -> P, W\nright_polar(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> P, W Compute the right polar decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments Keyword arguments are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.right_polar! . source TensorAlgebra.svd  —  Function svd(A::AbstractArray, labels_A, labels_codomain, labels_domain; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, ndims_codomain::Val; kwargs...) -> U, S, Vᴴ\nsvd(A::AbstractArray, biperm::AbstractBlockPermutation{2}; kwargs...) -> U, S, Vᴴ Compute the SVD decomposition of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. Keyword arguments full::Bool=false : select between a \"thick\" or a \"thin\" decomposition, where both  U  and  Vᴴ  are unitary or isometric. trunc : Truncation keywords for  svd_trunc . Not compatible with  full=true . Other keywords are passed on directly to MatrixAlgebraKit. See also  MatrixAlgebraKit.svd_full! ,  MatrixAlgebraKit.svd_compact! , and  MatrixAlgebraKit.svd_trunc! . source TensorAlgebra.svdvals  —  Function svdvals(A::AbstractArray, labels_A, labels_codomain, labels_domain) -> S\nsvdvals(A::AbstractArray, perm_codomain::Tuple{Vararg{Int}}, perm_domain::Tuple{Vararg{Int}}) -> S\nsvdvals(A::AbstractArray, ndims_codomain::Val) -> S\nsvdvals(A::AbstractArray, biperm::AbstractBlockPermutation{2}) -> S Compute the singular values of a generic N-dimensional array, by interpreting it as a linear map from the domain to the codomain indices. These can be specified either via their labels or directly through a bi-permutation. The output is a vector of singular values. See also  MatrixAlgebraKit.svd_vals! . source TensorAlgebra.MatrixAlgebra.truncdegen  —  Method truncdegen(trunc::TruncationStrategy; atol::Real=0, rtol::Real=0) Modify a truncation strategy so that if the truncation falls within a degenerate subspace, the entire subspace gets truncated as well. A value  val  is considered degenerate if  norm(val - truncval) ≤ max(atol, rtol * norm(truncval))  where  truncval  is the largest value truncated by the original truncation strategy  trunc . For now, this truncation strategy assumes the spectrum being truncated has already been reverse sorted and the strategy being wrapped outputs a contiguous subset of values including the largest one. It also only truncates for now, so may not respect if a minimum dimension was requested in the strategy being wrapped. These restrictions may be lifted in the future or provided through a different truncation strategy. source"},{"id":39,"pagetitle":"Home","title":"BlockSparseArrays.jl","ref":"/ITensorDocsNext/BlockSparseArrays/stable/#BlockSparseArrays.jl","content":" BlockSparseArrays.jl A block sparse array type in Julia based on the  BlockArrays.jl  interface."},{"id":40,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/BlockSparseArrays/stable/#Support","content":" Support BlockSparseArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":41,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/BlockSparseArrays/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"BlockSparseArrays\")"},{"id":42,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/BlockSparseArrays/stable/#Examples","content":" Examples using BlockArrays: Block\nusing BlockSparseArrays: BlockSparseArray, blockstoredlength\nusing Test: @test\n\na = BlockSparseArray{Float64}(undef, [2, 3], [2, 3])\na[Block(1, 2)] = randn(2, 3)\na[Block(2, 1)] = randn(3, 2)\n@test blockstoredlength(a) == 2\nb = a .+ 2 .* a'\n@test Array(b) ≈ Array(a) + 2 * Array(a')\n@test blockstoredlength(b) == 2 Test Passed This page was generated using  Literate.jl ."},{"id":45,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/BlockSparseArrays/stable/reference/#Reference","content":" Reference BlockSparseArrays.BlockDiagonalAlgorithm  —  Type BlockDiagonalAlgorithm([f]) <: MatrixAlgebraKit.AbstractAlgorithm Type for handling algorithms on a block-by-block basis, which is possible for block-diagonal input matrices. Additionally this algorithm may take a function that, given the individual blocks, returns the algorithm that will be used. This can be leveraged to allow for different algorithms for each block. source BlockSparseArrays.BlockDiagonalTruncationStrategy  —  Type BlockDiagonalTruncationStrategy(strategy::TruncationStrategy) A wrapper for  TruncationStrategy  that implements the wrapped strategy on a block-by-block basis, which is possible if the input matrix is a block-diagonal matrix. source BlockSparseArrays.BlockPermutedDiagonalAlgorithm  —  Type BlockPermutedDiagonalAlgorithm([f]) <: MatrixAlgebraKit.AbstractAlgorithm Type for handling algorithms on a block-by-block basis, which is possible for block-diagonal or block-permuted-diagonal input matrices. The algorithms proceed by first permuting to a block-diagonal form, and then carrying out the algorithm. Additionally this algorithm may take a function that, given the individual blocks, returns the algorithm that will be used. This can be leveraged to allow for different algorithms for each block. source BlockSparseArrays.BlockSparseArray  —  Type BlockSparseArray{T}(undef, dims)\nBlockSparseArray{T,N}(undef, dims)\nBlockSparseArray{T,N,A}(undef, dims) Construct an uninitialized N-dimensional BlockSparseArray containing elements of type T.  dims  should be a list of block lengths in each dimension or a list of blocked ranges representing the axes. source SparseArraysBase.SparseArrayDOK  —  Method SparseArrayDOK{T}(undef_blocks, axes)\nSparseArrayDOK{T,N}(undef_blocks, axes) Construct the block structure of an undefined BlockSparseArray that will have blocked axes  axes . Note that  undef_blocks  is defined in  BlockArrays.jl  and should be imported from that package to use it as an input to this constructor. source BlockSparseArrays.sparsemortar  —  Method sparsemortar(blocks::AbstractArray{<:AbstractArray{T,N},N}, axes) -> ::BlockSparseArray{T,N} Construct a block sparse array from a sparse array of arrays and specified blocked axes. The block sizes must be commensurate with the blocks of the axes. source"},{"id":48,"pagetitle":"Home","title":"SparseArraysBase.jl","ref":"/ITensorDocsNext/SparseArraysBase/stable/#SparseArraysBase.jl","content":" SparseArraysBase.jl"},{"id":49,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Support","content":" Support SparseArraysBase.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":50,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"SparseArraysBase\")"},{"id":51,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/SparseArraysBase/stable/#Examples","content":" Examples using SparseArraysBase: SparseArrayDOK, SparseMatrixDOK, SparseVectorDOK, eachstoredindex,\n    getstoredindex, getunstoredindex, isstored, setstoredindex!, setunstoredindex!,\n    storedlength, storedpairs, storedvalues, zero!\nusing Test: @test, @test_throws\n\na = SparseArrayDOK{Float64}(undef, 2, 2) 2×2 SparseArraysBase.SparseMatrixDOK{Float64, FillArrays.Zeros{Float64, 2, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}}}}:\n  ⋅    ⋅ \n  ⋅    ⋅  AbstractArray interface: @test iszero(a)\n@test iszero(sum(a))\n@test iszero(storedlength(a))\n\na[1, 2] = 12\n@test a == [0 12; 0 0]\n@test a[1, 1] == 0\n@test a[2, 1] == 0\n@test a[1, 2] == 12\n@test a[2, 2] == 0 Test Passed SparseArraysBase interface: using Dictionaries: IndexError\n@test issetequal(eachstoredindex(a), [CartesianIndex(1, 2)])\n@test getstoredindex(a, 1, 2) == 12\n@test_throws IndexError getstoredindex(a, 1, 1)\n@test getunstoredindex(a, 1, 1) == 0\n@test getunstoredindex(a, 1, 2) == 0\n@test !isstored(a, 1, 1)\n@test isstored(a, 1, 2)\n@test setstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test_throws IndexError setstoredindex!(copy(a), 21, 2, 1)\n@test_throws IndexError setunstoredindex!(copy(a), 21, 1, 2) == [0 21; 0 0]\n@test storedlength(a) == 1\n@test issetequal(storedpairs(a), [CartesianIndex(1, 2) => 12])\n@test issetequal(storedvalues(a), [12])\n@test sum(a) == 12\n@test isreal(a)\n@test !iszero(a)\n@test mapreduce(x -> 2x, +, a) == 24 Test Passed AbstractArray functionality: b = a .+ 2 .* a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [0 12; 24 0]\n@test storedlength(b) == 2\n@test sum(b) == 36\n@test isreal(b)\n@test !iszero(b)\n@test mapreduce(x -> 2x, +, b) == 72\n\nb = permutedims(a, (2, 1))\n@test b isa SparseMatrixDOK{Float64}\n@test b[1, 1] == a[1, 1]\n@test b[2, 1] == a[1, 2]\n@test b[1, 2] == a[2, 1]\n@test b[2, 2] == a[2, 2]\n\nb = a * a'\n@test b isa SparseMatrixDOK{Float64}\n@test b == [144 0; 0 0]\n@test storedlength(b) == 1 Test Passed Second column. b = a[1:2, 2]\n@test b isa SparseVectorDOK{Float64}\n@test b == [12, 0]\n@test storedlength(b) == 1\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na .= 2\nfor I in eachindex(a)\n    @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 2)\nfor I in eachindex(a)\n    @test a[I] == 2\nend\n@test storedlength(a) == length(a)\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\nfill!(a, 0)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nzero!(a)\n@test iszero(a)\n@test iszero(storedlength(a))\n\na = SparseArrayDOK{Float64}(undef, 2, 2)\na[1, 2] = 12\nb = zero(a)\n@test iszero(b)\n@test iszero(storedlength(b)) Test Passed This page was generated using  Literate.jl ."},{"id":54,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/SparseArraysBase/stable/reference/#Reference","content":" Reference SparseArraysBase.SparseArrayDOK  —  Type SparseArrayDOK{T,N,F} <: AbstractSparseArray{T,N} N -dimensional sparse dictionary-of-keys (DOK) array with elements of type  T , with a specified background of unstored values  unstored  of the size of the array. source SparseArraysBase.SparseArrayDOK  —  Method SparseArrayDOK{T}(undef, dims...)\nSparseArrayDOK{T,N}(undef, dims...) Construct an uninitialized  N -dimensional  SparseArrayDOK  containing elements of type  T .  N  can either be supplied explicitly, or be determined by the length or number of  dims . source SparseArraysBase.ZeroPreserving  —  Type abstract type ZeroPreserving <: Function end Holy Trait to indicate how a function interacts with abstract zero values: StrongPreserving  : output is guaranteed to be zero if  any  input is. WeakPreserving  : output is guaranteed to be zero if  all  inputs are. NonPreserving  : no guarantees on output. To attempt to automatically determine this, either  ZeroPreserving(f, A::AbstractArray...)  or  ZeroPreserving(f, T::Type...)  can be used/overloaded. Warning incorrectly registering a function to be zero-preserving will lead to silently wrong results. source SparseArraysBase.eachstoredindex  —  Function eachstoredindex(A::AbstractArray...)\neachstoredindex(style::IndexStyle, A::AbstractArray...) An iterable over all indices of the stored values. For multiple arrays, the iterable contains all indices where at least one input has a stored value. The type of indices can be controlled through  style , which will default to a compatible style for all inputs. The order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as  storedvalues . See also  storedvalues ,  storedpairs  and  storedlength . source SparseArraysBase.getstoredindex  —  Method getstoredindex(A::AbstractArray, I...) -> eltype(A) Obtain  getindex(A, I...)  with the guarantee that there is a stored entry at that location. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.getunstoredindex  —  Method getunstoredindex(A::AbstractArray, I...) -> eltype(A) Obtain the value that would be returned by  getindex(A, I...)  when there is no stored entry at that location. By default, this takes an explicit copy of the  getindex  implementation to mimick a newly instantiated object. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.isstored  —  Method isstored(A::AbstractArray, I...) -> Bool Check if the array  A  has a stored entry at the location specified by indices  I... . For generic array types this defaults to  true  whenever the indices are inbounds, but sparse array types might overload this function when appropriate. Similar to  Base.getindex , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.setstoredindex!  —  Method setstoredindex!(A::AbstractArray, v, I...) -> A setindex!(A, v, I...)  with the guarantee that there is a stored entry at the given location. Similar to  Base.setindex! , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.setunstoredindex!  —  Method setunstoredindex!(A::AbstractArray, v, I...) -> A setindex!(A, v, I...)  with the guarantee that there is no stored entry at the given location. Similar to  Base.setindex! , new definitions should be in line with  IndexStyle(A) . source SparseArraysBase.sparse  —  Method sparse(storage::Union{AbstractDict,AbstractDictionary}, dims...[; getunstored]) Construct an  N -dimensional  SparseArrayDOK  containing elements of type  T . Both  T  and  N  can either be supplied explicitly or be determined by the  storage  and the length or number of  dims . If  dims  aren't specified, the size will be determined automatically from the input indices. This constructor does not take ownership of the supplied storage, and will result in an independent container. source SparseArraysBase.sparserand  —  Function sparserand([rng], [T::Type], dims; density::Real=0.5, randfun::Function=rand) -> A::SparseArrayDOK{T} Create a random size  dims  sparse array in which the probability of any element being stored is independently given by  density . The optional  rng  argument specifies a random number generator, see also  Random . The optional  T  argument specifies the element type, which defaults to  Float64 . The optional  randfun  argument can be used to control the type of random elements, and should support the signature  randfun(rng, T, N)  to generate  N  entries of type  T . See also  sparserand! . source SparseArraysBase.sparserand!  —  Function sparserand!([rng], A::AbstractArray; density::Real=0.5, randfun::Function=rand) -> A Overwrite part of an array with random entries, where the probability of overwriting is independently given by  density . The optional  rng  argument specifies a random number generator, see also  Random . The optional  randfun  argument can be used to control the type of random elements, and should support the signature  randfun(rng, T, N)  to generate  N  entries of type  T . See also  sparserand . source SparseArraysBase.sparsezeros  —  Function sparsezeros([T::Type], dims[; getunstored]) -> A::SparseArrayDOK{T} Create an empty size  dims  sparse array. The optional  T  argument specifies the element type, which defaults to  Float64 . source SparseArraysBase.storedlength  —  Function storedlength(A::AbstractArray) -> Int The number of values that are currently being stored. source SparseArraysBase.storedpairs  —  Function storedpairs(A::AbstractArray) -> (k, v)... An iterable over all stored indices and their corresponding stored values. The indices are compatible with  IndexStyle(A) . The order of the iterable is not guaranteed to be fixed or sorted. See also  eachstoredindex  and  storedvalues . source SparseArraysBase.storedvalues  —  Function storedvalues(A::AbstractArray) -> v... An iterable over all stored values. The order of the iterable is not guaranteed to be fixed or sorted, and should not be assumed to be the same as  eachstoredindex . source"},{"id":57,"pagetitle":"Home","title":"DiagonalArrays.jl","ref":"/ITensorDocsNext/DiagonalArrays/stable/#DiagonalArrays.jl","content":" DiagonalArrays.jl A n-dimensional diagonal array type in Julia."},{"id":58,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/DiagonalArrays/stable/#Support","content":" Support DiagonalArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":59,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/DiagonalArrays/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"DiagonalArrays\")"},{"id":60,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/DiagonalArrays/stable/#Examples","content":" Examples using DiagonalArrays:\n    DiagIndex, DiagIndices, DiagonalArray, DiagonalMatrix, diaglength, isdiagindex\nusing Test: @test\n\nfunction main()\n    d = DiagonalMatrix([1.0, 2.0, 3.0])\n    @test eltype(d) == Float64\n    @test diaglength(d) == 3\n    @test size(d) == (3, 3)\n    @test d[1, 1] == 1\n    @test d[2, 2] == 2\n    @test d[3, 3] == 3\n    @test d[1, 2] == 0\n\n    d = DiagonalArray([1.0, 2.0, 3.0], 3, 4, 5)\n    @test eltype(d) == Float64\n    @test diaglength(d) == 3\n    @test d[1, 1, 1] == 1\n    @test d[2, 2, 2] == 2\n    @test d[3, 3, 3] == 3\n    @test d[1, 2, 1] == 0\n\n    d[2, 2, 2] = 22\n    @test d[2, 2, 2] == 22\n\n    d_r = reshape(d, 3, 20)\n    @test size(d_r) == (3, 20)\n    @test all(I -> d_r[I] == d[I], LinearIndices(d))\n\n    @test length(d[DiagIndices(:)]) == 3\n    @test Array(d) == d\n    @test d[DiagIndex(2)] == d[2, 2, 2]\n\n    d[DiagIndex(2)] = 222\n    @test d[2, 2, 2] == 222\n\n    a = randn(3, 4, 5)\n    new_diag = randn(3)\n    a[DiagIndices(:)] = new_diag\n    d[DiagIndices(:)] = a[DiagIndices(:)]\n\n    @test a[DiagIndices(:)] == new_diag\n    @test d[DiagIndices(:)] == new_diag\n\n    permuted_d = permutedims(d, (3, 2, 1))\n    @test permuted_d isa DiagonalArray\n    @test permuted_d[DiagIndices(:)] == d[DiagIndices(:)]\n    @test size(d) == (3, 4, 5)\n    @test size(permuted_d) == (5, 4, 3)\n    for I in eachindex(d)\n        if !isdiagindex(d, I)\n            @test iszero(d[I])\n        else\n            @test !iszero(d[I])\n        end\n    end\n\n    mapped_d = map(x -> 2x, d)\n    @test mapped_d isa DiagonalArray\n    @test mapped_d == map(x -> 2x, Array(d))\n\n    return nothing\nend\n\nmain() This page was generated using  Literate.jl ."},{"id":63,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/DiagonalArrays/stable/reference/#Reference","content":" Reference DiagonalArrays.diagonal  —  Method diagonal(m::AbstractMatrix) -> AbstractMatrix Return a diagonal matrix from a matrix  m  where the diagonal values are copied from the diagonal of  m . This is an extension of  LinearAlgebra.Diagonal , designed to avoid the implication of the output type. Defaults to  diagonal(copy(diagview(m))) , which in general is equivalent to  Diagonal(m) . source DiagonalArrays.diagonal  —  Method diagonal(v::AbstractVector) -> AbstractMatrix Return a diagonal matrix from a vector  v . This is an extension of  LinearAlgebra.Diagonal , designed to avoid the implication of the output type. Defaults to  Diagonal(v) . source DiagonalArrays.diagonaltype  —  Function diagonaltype(::AbstractVector) -> Type{<:AbstractMatrix}\ndiagonaltype(::Type{<:AbstractVector}) -> Type{<:AbstractMatrix}\ndiagonaltype(::AbstractMatrix) -> Type{<:AbstractMatrix}\ndiagonaltype(::Type{<:AbstractMatrix}) -> Type{<:AbstractMatrix} Return the type of diagonal matrix that would be created from a vector or matrix using the  diagonal  function. source"},{"id":66,"pagetitle":"Home","title":"KroneckerArrays.jl","ref":"/ITensorDocsNext/KroneckerArrays/stable/#KroneckerArrays.jl","content":" KroneckerArrays.jl"},{"id":67,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/KroneckerArrays/stable/#Support","content":" Support KroneckerArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":68,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/KroneckerArrays/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"KroneckerArrays\")"},{"id":69,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/KroneckerArrays/stable/#Examples","content":" Examples using KroneckerArrays: KroneckerArrays Examples go here. This page was generated using  Literate.jl ."},{"id":72,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/KroneckerArrays/stable/reference/#Reference","content":" Reference KroneckerArrays.AbstractKroneckerArray  —  Type abstract type AbstractKroneckerArray{T, N} <: AbstractArray{T, N} end Abstract supertype for arrays that have a kronecker product structure, i.e. that can be written as  AB = A ⊗ B . source KroneckerArrays.CartesianPair  —  Type CartesianPair(a, b) Represents a single element, the cartesian product of two arbitrary objects  a  and  b . source KroneckerArrays.CartesianProduct  —  Type CartesianProduct(a::AbstractVector, b::AbstractVector) Represents the cartesian product of two collections  a  and  b . source KroneckerArrays.CartesianProductUnitRange  —  Type CartesianProductUnitRange(a::AbstractUnitRange, b::AbstractUnitRange, range::AbstractUnitRange{T}) <: AbstractUnitRange{T} Similar to  CartesianProductVector , this represents the cartesian product of two ranges  a  and  b . However, as a range it will behave as  range , rather than  CartesianPair s of the elements of  a  and  b . source KroneckerArrays.CartesianProductVector  —  Type CartesianProductVector(a::AbstractVector, b::AbstractVector, values::AbstractVector{T}) <: AbstractVector{T} Similar to the  CartesianProduct , this represents the cartesian product of two collections  a  and  b . However, as a vector it will behave as  values , rather than  CartesianPair s of the elements of  a  and  b . source KroneckerArrays.:×  —  Function ×(args...)\ntimes(args...) Construct an object that represents the Cartesian product of the provided  args . By default this constructs the singular  CartesianPair  for unknown values, while attempting to promote to more structured types wherever possible. See also  CartesianProduct ,  CartesianProductVector  and  CartesianProductUnitRange . source KroneckerArrays.:⊗  —  Function ⊗(args...)\notimes(args...) Construct an object that represents the Kronecker product of the provided  args . source KroneckerArrays.cartesianproduct  —  Function cartesianproduct(a::AbstractVector, b::AbstractVector, [values::AbstractVector])::AbstractVector Construct an  AbstractVector  that represents the cartesian product  a × b , but behaves as  values . This behaves similar to  × , but forces promotion to a  AbstractVector . source KroneckerArrays.cartesianrange  —  Function cartesianrange(a::AbstractUnitRange, b::AbstractUnitRange, [range::AbstractUnitRange])::AbstractUnitRange Construct a  UnitRange  that represents the cartesian product  a × b , but behaves as  range . This behaves similar to  × , but forces promotion to a  AbstractUnitRange . source KroneckerArrays.kroneckerfactors  —  Function kroneckerfactors(x) -> Tuple\nkroneckerfactors(x, i) = kroneckerfactors(x)[i] Extract the factors of  x , where  x  is an object that represents a lazily composed product type. source KroneckerArrays.kroneckerfactortypes  —  Function kroneckerfactortypes(x) -> Tuple\nkroneckerfactortypes(x, i) = kroneckerfactortypes(x)[i] Extract the types of the factors of  x , where  x  is an object or type that represents a lazily composed product type. source KroneckerArrays.unproduct  —  Function unproduct(a) For an object that holds a cartesian product of indices and their corresponding values, this function removes the cartesian product layer and returns only the values. source"},{"id":75,"pagetitle":"Home","title":"FusionTensors.jl","ref":"/ITensorDocsNext/FusionTensors/stable/#FusionTensors.jl","content":" FusionTensors.jl"},{"id":76,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/FusionTensors/stable/#Support","content":" Support FusionTensors.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":77,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/FusionTensors/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"FusionTensors\")"},{"id":78,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/FusionTensors/stable/#Examples","content":" Examples using FusionTensors: FusionTensors Examples go here. This page was generated using  Literate.jl ."},{"id":81,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/FusionTensors/stable/reference/#Reference","content":" Reference"},{"id":84,"pagetitle":"Home","title":"GradedArrays.jl","ref":"/ITensorDocsNext/GradedArrays/stable/#GradedArrays.jl","content":" GradedArrays.jl"},{"id":85,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/GradedArrays/stable/#Support","content":" Support GradedArrays.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":86,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/GradedArrays/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"GradedArrays\")"},{"id":87,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/GradedArrays/stable/#Examples","content":" Examples using GradedArrays: GradedArrays Examples go here. This page was generated using  Literate.jl ."},{"id":90,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/GradedArrays/stable/reference/#Reference","content":" Reference GradedArrays.GradedOneTo  —  Type const GradedOneTo{I, R1, R2} = BlockOneTo{Int, Vector{SectorUnitRange{I, R1, R2}}, Vector{Int}} See also  SectorUnitRange  and  GradedUnitRange . source GradedArrays.GradedUnitRange  —  Type const GradedUnitRange{I, R1, R2} = BlockUnitRange{Int, Vector{SectorUnitRange{I, R1, R2}}, Vector{Int}} Type alias for the axis type of graded arrays. This represents the blocked combination of ranges, where each block is a  SectorUnitRange  with sector labels of type  I  and underlying range types  R1  and  R2 . See also  SectorUnitRange  and  GradedOneTo . source GradedArrays.SectorArray  —  Type SectorArray(sectors, data) <: AbstractKroneckerArray A representation of a general symmetric array as the combination of a structural part ( sectors ) and a data part ( data ). This can be thought of as a direct implementation of the Wigner-Eckart theorem. source GradedArrays.SectorDelta  —  Type SectorDelta{T}(sectors::NTuple{N, I}) <: AbstractArray{T, N} An immutable representation of the structural tensor associated to the representation space of a number of sectors. For abelian symmetries, this boils down to a scalar which can always be normalized to 1. source GradedArrays.SectorOneTo  —  Type const SectorOneTo{I <: SectorRange} = SectorUnitRange{I, Base.OneTo{Int}, Base.OneTo{Int}} source GradedArrays.SectorRange  —  Type SectorRange(sector::TKS.Sector, isdual::Bool) Unit range with elements of type  Int  that additionally stores a sector to denote the grading. Equivalent to  Base.OneTo(length(sector)) . Additionally holds a flag to denote the duality. source GradedArrays.SectorUnitRange  —  Type const SectorUnitRange{I <: SectorRange, RB <: AbstractUnitRange{Int}, R <: AbstractUnitRange{Int}} =\n    CartesianProductUnitRange{Int, I, RB, R} Type alias for the cartesian product of a sector range of type  I , and a unit range of type  RB , which yields a total range of type  R . source GradedArrays.flux  —  Function flux(a::AbstractArray)\nflux(a::AbstractArray, I::Block...) Compute the total flux of an  AbstractArray , defined as the fusion of all of the incoming charges, or the flux associated to a provided block. Whenever the flux cannot be meaningfully computed, for example for non-graded arrays, or empty ones, this function returns  UndefinedFlux . source GradedArrays.gradedrange  —  Method gradedrange(xs::AbstractVector{<:Pair}) Construct a graded range from the provided list of  sector => range  pairs. source GradedArrays.sectorrange  —  Function sectorrange(sector, range)\nsectorrange(sector, dim) Construct a  SectorUnitRange  for the given sector and dimension or range. source"},{"id":93,"pagetitle":"Home","title":"FunctionImplementations.jl","ref":"/ITensorDocsNext/FunctionImplementations/stable/#FunctionImplementations.jl","content":" FunctionImplementations.jl"},{"id":94,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/FunctionImplementations/stable/#Support","content":" Support FunctionImplementations.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":95,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/FunctionImplementations/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"FunctionImplementations\")"},{"id":96,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/FunctionImplementations/stable/#Examples","content":" Examples using FunctionImplementations: FunctionImplementations Examples go here. This page was generated using  Literate.jl ."},{"id":99,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/FunctionImplementations/stable/reference/#Reference","content":" Reference FunctionImplementations.AbstractArrayImplementationStyle  —  Type FunctionImplementations.AbstractArrayImplementationStyle <: ImplementationStyle  is the abstract supertype for any style associated with an  AbstractArray  type. Note that if two or more  AbstractArrayImplementationStyle  subtypes conflict, the resulting style will fall back to that of  Array s. If this is undesirable, you may need to define binary  ImplementationStyle  rules to control the output type. See also  FunctionImplementations.DefaultArrayImplementationStyle . source FunctionImplementations.DefaultArrayImplementationStyle  —  Type FunctionImplementations.DefaultArrayImplementationStyle()  is a  FunctionImplementations.ImplementationStyle  indicating that an object behaves as an array. Specifically,  DefaultArrayImplementationStyle  is used for any  AbstractArray  type that hasn't defined a specialized style, and in the absence of overrides from other arguments the resulting output type is  Array . source FunctionImplementations.Implementation  —  Type FunctionImplementations.Implementation(f, s)  wraps a function  f  with a style  s . This can be used to create function implementations that behave differently based on the style of their arguments. source FunctionImplementations.ImplementationStyle  —  Type ImplementationStyle  is an abstract type and trait-function used to determine behavior of objects.  ImplementationStyle(typeof(x))  returns the style associated with  x . To customize the behavior of a type, one can declare a style by defining a type/method pair struct MyContainerImplementationStyle <: ImplementationStyle end\nFunctionImplementations.ImplementationStyle(::Type{<:MyContainer}) = MyContainerImplementationStyle() source FunctionImplementations.ImplementationStyle  —  Method (s::ImplementationStyle)(f) Calling a ImplementationStyle  s  with a function  f  as  s(f)  is a shorthand for creating a  FunctionImplementations.Implementation  object wrapping the function  f  with ImplementationStyle  s . source FunctionImplementations.ImplementationStyle  —  Method ImplementationStyle(::ImplementationStyle1, ::ImplementationStyle2) = ImplementationStyle3() Indicate how to resolve different  ImplementationStyle s. For example, ImplementationStyle(::Primary, ::Secondary) = Primary() would indicate that style  Primary  has precedence over  Secondary . You do not have to (and generally should not) define both argument orders. The result does not have to be one of the input arguments, it could be a third type. source FunctionImplementations.permuteddims  —  Method permuteddims(a::AbstractArray, perm) Lazy version of  permutedims . Defaults to constructing a  Base.PermutedDimsArray  but can be customized to output a different type of array. source FunctionImplementations.result_style  —  Function result_style(s1::ImplementationStyle[, s2::ImplementationStyle])::ImplementationStyle Takes one or two  ImplementationStyle s and combines them using  ImplementationStyle  to determine a common  ImplementationStyle . Examples julia> FunctionImplementations.result_style(\n           FunctionImplementations.DefaultArrayImplementationStyle(),\n           FunctionImplementations.DefaultArrayImplementationStyle()\n       )\nFunctionImplementations.DefaultArrayImplementationStyle()\n\njulia> FunctionImplementations.result_style(\n           FunctionImplementations.UnknownImplementationStyle(),\n           FunctionImplementations.DefaultArrayImplementationStyle()\n       )\nFunctionImplementations.DefaultArrayImplementationStyle() source FunctionImplementations.style  —  Function style(cs...)::ImplementationStyle Decides which  ImplementationStyle  to use for any number of value arguments. Uses  ImplementationStyle  to get the style for each argument, and uses  result_style  to combine styles. Examples julia> FunctionImplementations.style([1], [1 2; 3 4])\nFunctionImplementations.DefaultArrayImplementationStyle() source FunctionImplementations.zero!  —  Method zero!(a::AbstractArray) In-place version of  zero(a) , sets all entries of  a  to zero. source FunctionImplementations.Concatenate  —  Module module Concatenate Alternative implementation for  Base.cat  through  Concatenate.cat(!) . This is mostly a copy of the Base implementation, with the main difference being that the destination is chosen based on all inputs instead of just the first. Additionally, we have an intermediate representation in terms of a Concatenated object, reminiscent of how Broadcast works. The various entry points for specializing behavior are: Destination selection can be achieved through: Base.similar(concat::Concatenated{Style}, ::Type{T}, axes) where {Style} Custom implementations: Base.copy(concat::Concatenated{Style}) # custom implementation of cat\nBase.copyto!(dest, concat::Concatenated{Style}) # custom implementation of cat! based on style\nBase.copyto!(dest, concat::Concatenated{Nothing}) # custom implementation of cat! based on typeof(dest) source FunctionImplementations.Concatenate.Concatenated  —  Type Concatenated{Style, Dims, Args <: Tuple} Lazy representation of the concatenation of various  Args  along  Dims , in order to provide hooks to customize the implementation. source FunctionImplementations.Concatenate.cat!  —  Method Concatenate.cat!(dest, args...; dims) Concatenate the supplied  args  along dimensions  dims , placing the result into  dest . source FunctionImplementations.Concatenate.cat  —  Method Concatenate.cat(args...; dims) Concatenate the supplied  args  along dimensions  dims . See also  concatenate  and  cat! . source FunctionImplementations.Concatenate.concatenate  —  Method concatenate(dims, args...) Concatenate the supplied  args  along dimensions  dims . See also  cat  and  cat! . source"},{"id":102,"pagetitle":"Home","title":"TypeParameterAccessors.jl","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/#TypeParameterAccessors.jl","content":" TypeParameterAccessors.jl"},{"id":103,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"TypeParameterAccessors\")"},{"id":104,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/#Examples","content":" Examples using Test: @test\nusing TypeParameterAccessors Get type parameters: @test type_parameters(Array{Float64}, 1) == Float64\n@test type_parameters(Matrix{Float64}, 2) == 2\n@test type_parameters(Matrix{Float64}) == (Float64, 2)\n@test type_parameters(Array{Float64}, eltype) == Float64\n@test type_parameters(Matrix{Float64}, ndims) == 2\n@test type_parameters(Matrix{Float64}, (eltype, ndims)) == (Float64, 2) Test Passed Set type parameters: @test set_type_parameters(Array, 1, Float32) == Array{Float32}\n@test set_type_parameters(Array, (1,), (Float32,)) == Array{Float32}\n@test set_type_parameters(Array, (1, 2), (Float32, 2)) == Matrix{Float32}\n@test set_type_parameters(Array, (eltype,), (Float32,)) == Array{Float32}\n@test set_type_parameters(Array, (eltype, ndims), (Float32, 2)) == Matrix{Float32} Test Passed Specify type parameters: @test specify_type_parameters(Array{Float64}, (eltype, ndims), (Float32, 2)) ==\n  Matrix{Float64}\n@test specify_type_parameters(Array{Float64}, ndims, 2) == Matrix{Float64}\n@test specify_type_parameters(Array{Float64}, eltype, Float32) == Array{Float64} Test Passed Unspecify type parameters: @test unspecify_type_parameters(Matrix{Float32}) == Array\n@test unspecify_type_parameters(Matrix{Float32}, 1) == Matrix\n@test unspecify_type_parameters(Matrix{Float32}, (eltype,)) == Matrix\n@test unspecify_type_parameters(Matrix{Float32}, (ndims,)) == Array{Float32} Test Passed Getting default type parameters @test default_type_parameters(Array) == (Float64, 1)\n@test default_type_parameters(Array, eltype) == Float64\n@test default_type_parameters(Array, 2) == 1\n@test default_type_parameters(Array, (eltype, ndims)) == (Float64, 1) Test Passed Set default type parameters: @test set_default_type_parameters(Array) == Vector{Float64}\n@test set_default_type_parameters(Array, (eltype,)) == Array{Float64}\n@test set_default_type_parameters(Array, 2) == Vector Test Passed Specify default type parameters: @test specify_default_type_parameters(Matrix, (eltype, ndims)) == Matrix{Float64}\n@test specify_default_type_parameters(Matrix, eltype) == Matrix{Float64}\n@test specify_default_type_parameters(Array{Float32}, (eltype, ndims)) == Vector{Float32} Test Passed Other functionality: parenttype unwrap_array_type is_wrapped_array set_eltype set_ndims set_parenttype similartype This page was generated using  Literate.jl ."},{"id":107,"pagetitle":"Library","title":"Index","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Index","content":" Index Docstrings for the  TypeParameterAccessors.jl  public API."},{"id":108,"pagetitle":"Library","title":"Contents","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Contents","content":" Contents Contents Index Type parameter interface Array -type tools"},{"id":109,"pagetitle":"Library","title":"Index","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Index-2","content":" Index TypeParameterAccessors.Position TypeParameterAccessors.default_type_parameters TypeParameterAccessors.get_type_parameters TypeParameterAccessors.is_parameter_specified TypeParameterAccessors.nparameters TypeParameterAccessors.position TypeParameterAccessors.set_default_type_parameters TypeParameterAccessors.set_type_parameters TypeParameterAccessors.specify_default_type_parameters TypeParameterAccessors.specify_type_parameters TypeParameterAccessors.type_parameters TypeParameterAccessors.unspecify_type_parameters"},{"id":110,"pagetitle":"Library","title":"Type parameter interface","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Type-parameter-interface","content":" Type parameter interface TypeParameterAccessors.position  —  Function position(type::Type, position_name)::Position An optional interface function. Defining this allows accessing a parameter at the defined position using the  position_name . For example, defining  TypeParameterAccessors.position(::Type{<:MyType}, ::typeof(eltype)) = Position(1)  allows accessing the first type parameter with  type_parameters(MyType(...), eltype) , in addition to the standard  type_parameters(MyType(...), 1)  or  type_parameters(MyType(...), Position(1)) . source TypeParameterAccessors.Position  —  Type struct Position{P} end Singleton type to statically represent the type-parameter position. This is meant for internal use as a  Val -like structure to improve type-inference. source TypeParameterAccessors.type_parameters  —  Function type parameters(type or_obj, [pos]) Return a tuple containing the type parameters of a given type or object. Optionally you can specify a position to just get the parameter for that position, or a tuple of positions to get a subset of parameters. Errors if parameters are unspecified. For an unchecked version, see  get_type_parameters . source TypeParameterAccessors.get_type_parameters  —  Function get type parameters(type or obj, [pos]) Return a tuple containing the type parameters of a given type or object. Optionally you can specify a position to just get the parameter for that position, or a tuple of positions to get a subset of parameters. If parameters are unspecified, returns a  TypeVar . For a checked version, see  type_parameters . source TypeParameterAccessors.default_type_parameters  —  Function default type parameters(type::Type)::Tuple An optional interface function. Defining this allows filling type parameters of the specified type with default values. This function should output a Tuple of the default values, with exactly one for each type parameter slot of the type. source TypeParameterAccessors.nparameters  —  Function nparameters(type or obj) Return the number of type parameters for a given type or object. source TypeParameterAccessors.is_parameter_specified  —  Function is parameter specified(type::Type, pos) Return whether or not the type parameter at a given position is considered specified. source TypeParameterAccessors.unspecify_type_parameters  —  Function unspecify type parameters(type::Type, [positions::Tuple])   unspecify type parameters(type::Type, position) Return a new type where the type parameters at the given positions are unset. source TypeParameterAccessors.set_type_parameters  —  Function set type parameters(type::Type, positions::Tuple, parameters::Tuple)   set type parameters(type::Type, position, parameter) Return a new type where the type parameters at the given positions are set to the provided values. source TypeParameterAccessors.set_default_type_parameters  —  Function set default type parameters(type::Type, [positions::Tuple])   set default type parameters(type::Type, position) Set the type parameters at the given positions to their default values. source TypeParameterAccessors.specify_type_parameters  —  Function specify type parameters(type::Type, positions::Tuple, parameters::Tuple)   specify type parameters(type::Type, position, parameter) Return a new type where the type parameters at the given positions are set to the provided values, only if they were previously unspecified. source TypeParameterAccessors.specify_default_type_parameters  —  Function specify default type parameters(type::Type, [positions::Tuple])   specify default type parameters(type::Type, position) Set the type parameters at the given positions to their default values, if they had not been specified. source"},{"id":111,"pagetitle":"Library","title":"Array-type tools","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/lib/#Array-type-tools","content":" Array -type tools"},{"id":114,"pagetitle":"Type parameters","title":"Type interface","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Type-interface","content":" Type interface The low-level interface of this package is centered around the ability to  get ,  set  and  specify  the type parameters of a given type."},{"id":115,"pagetitle":"Type parameters","title":"Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Type-Parameters","content":" Type Parameters The central concept in this package is a type parameter, which refers to the variables  A, B, ...  in type definitions: abstract type Foo{A,B,C,D} end\nstruct Bar{A,B,C,D} end In order to retrieve these parameters,  type_parameters  can be used, either to retrieve all parameters, or a single one: julia> type_parameters(Foo{1,2,3,4}) (1, 2, 3, 4) julia> type_parameters(Foo{1,2,3,4}, 2) 2 julia> type_parameters(Bar{:A,Int,2,Foo}) (:A, Int64, 2, Main.Foo) julia> type_parameters(Bar{:A,Int,2,Foo}, 4) Main.Foo Warning For consistency reasons, as well as due to the type system in Julia, these positions will always refer to the  base type . This means in particular that using positional type parameters in combination with type aliases can lead to unexpected results. For example,  const Foo_alias{D,C,B,A} = Foo{A,B,C,D}  would still have  type_parameters(Foo_alias) == (A, B, C, D) . In order to effectively pass on the information about  which  type parameter we want to manipulate, it can often be convenient to refer to type parameters not by their position, but rather by their meaning. In particular, this allows users to write more generic code, since the positions of type parameters have no special meaning in the Julia type system. Additionally, this avoids the unexpected results caused by type aliases. Often, these parameters have an associated function to retrieve them, such as  eltype  or  ndims . Therefore, the following syntax is also supported (and in general preferred): julia> type_parameters(Array{Int,2}, ndims) 2 julia> type_parameters(Vector{Float64}, eltype) Float64 This can not automatically be inferred for custom types however: julia> type_parameters(Bar{1}, ndims) # errors because `ndims` is not registered ERROR: MethodError: no method matching position(::Type{Main.Bar{1}}, ::typeof(ndims))\nThis error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.\n\nClosest candidates are:\n  position(::Type, ::Any)\n    @   TypeParameterAccessors   ~/work/TypeParameterAccessors.jl/TypeParameterAccessors.jl/src/ type_parameters.jl:30 \n  position(::Any, ::Any)\n    @   TypeParameterAccessors   ~/work/TypeParameterAccessors.jl/TypeParameterAccessors.jl/src/ type_parameters.jl:27 \n  position( ::Type{<:Array} , ::typeof(ndims))\n    @   TypeParameterAccessors   ~/work/TypeParameterAccessors.jl/TypeParameterAccessors.jl/src/base/ array.jl:2 \n  ... In order to support this, we internally pass everything through  position , which can be used to bind functions to positions. For type stability reasons, it is beneficial to return the static  TypeParameterAccessors.Position  instead of a regular integer. julia> TypeParameterAccessors.position(::Type{<:Bar}, ::typeof(ndims)) = TypeParameterAccessors.Position(1) julia> type_parameters(Bar{1}, ndims) 1 Warning While it might be tempting to define such functions for abstract types, this is in general not a good practice. The reason for this is again that the position of a specific type parameter is not something that is inherited by subtypes, which may decide to change the number as well as the order of the type parameters."},{"id":116,"pagetitle":"Type parameters","title":"Setting Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Setting-Type-Parameters","content":" Setting Type Parameters In a similar manner, it is also possible to alter the type parameters of a given type. That functionality is provided by  set_type_parameters : julia> set_type_parameters(Foo{1,2,3}, 4, :four) Main.Foo{1, 2, 3, :four} julia> set_type_parameters(Foo{1,2,3,4}, (1,3), (:A, :B)) Main.Foo{:A, 2, :B, 4}"},{"id":117,"pagetitle":"Type parameters","title":"Specifying and Unspecifying Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Specifying-and-Unspecifying-Type-Parameters","content":" Specifying and Unspecifying Type Parameters Finally, sometimes it is either required or useful to work with  UnionAll  types. These have type parameters that are either not specified or only bounded. For example,  Foo  is really a shorthand form of  Foo{A,B,C,D} where {A,B,C,D} . Starting from a  specified  type, you can go back to the unspecified form by unspecifying either some or all of the type parameters through  unspecify_type_parameters . julia> unspecify_type_parameters(Foo{1,2,3,4}) Main.Foo julia> unspecify_type_parameters(Foo{1,2,3,4}, 1) Main.Foo{A, 2, 3, 4} where A julia> unspecify_type_parameters(Foo{1,2,3,4}, (1, 3)) Main.Foo{A, 2, C, 4} where {A, C} Similarly, it is possible to set type parameters that have not been fully specified through  specify_type_parameters . julia> specify_type_parameter(Foo{1,2,3}, 4, 4) ERROR: UndefVarError: `specify_type_parameter` not defined in `Main`\nSuggestion: check for spelling errors or missing imports. julia> specify_type_parameters(Foo, (1, 2), (:A, Int)) Main.Foo{:A, Int64} Note that this function differs from  set_type_parameters  only by ignoring type parameters that have not been specified: julia> set_type_parameters(Foo{1,2,3}, (1, 4), (Int, Int)) Main.Foo{Int64, 2, 3, Int64} julia> specify_type_parameters(Foo{1,2,3}, (1, 4), (Int, Int)) Main.Foo{1, 2, 3, Int64}"},{"id":118,"pagetitle":"Type parameters","title":"Default Type Parameters","ref":"/ITensorDocsNext/TypeParameterAccessors/stable/type_interface/#Default-Type-Parameters","content":" Default Type Parameters Finally, it can sometimes be convenient to have default values for type parameters. This can be achieved by registering the default values through  default_type_parameters , and then setting or specifying them through  set_default_type_parameters  and  specify_default_type_parameters . julia> TypeParameterAccessors.default_type_parameters(::Type{<:Bar}) = (1, 2, 3, 4) julia> set_default_type_parameters(Bar) Main.Bar{1, 2, 3, 4} julia> specify_default_type_parameters(Bar{1,2}, (3, 4)) Main.Bar{1, 2, 3, 4}"},{"id":121,"pagetitle":"Home","title":"MapBroadcast.jl","ref":"/ITensorDocsNext/MapBroadcast/stable/#MapBroadcast.jl","content":" MapBroadcast.jl"},{"id":122,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/MapBroadcast/stable/#Support","content":" Support MapBroadcast.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":123,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/MapBroadcast/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"MapBroadcast\")"},{"id":124,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/MapBroadcast/stable/#Examples","content":" Examples using Base.Broadcast: broadcasted\nusing MapBroadcast: Mapped, mapped\nusing Test: @test\n\na = randn(2, 2)\nbc = broadcasted(*, 2, a)\nm = Mapped(bc)\nm′ = mapped(x -> 2x, a)\n@test copy(m) ≈ map(m.f, m.args...)\n@test copy(m) ≈ copy(m′)\n@test copy(m) ≈ copy(bc)\n@test axes(m) == axes(bc)\n@test copyto!(similar(m, Float64), m) ≈ copyto!(similar(bc, Float64), bc) Test Passed This page was generated using  Literate.jl ."},{"id":127,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/MapBroadcast/stable/reference/#Reference","content":" Reference"},{"id":130,"pagetitle":"Home","title":"BackendSelection.jl","ref":"/ITensorDocsNext/BackendSelection/stable/#BackendSelection.jl","content":" BackendSelection.jl"},{"id":131,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/BackendSelection/stable/#Support","content":" Support BackendSelection.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":132,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/BackendSelection/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"BackendSelection\")"},{"id":133,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/BackendSelection/stable/#Examples","content":" Examples using BackendSelection: BackendSelection Examples go here. This page was generated using  Literate.jl ."},{"id":136,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/BackendSelection/stable/reference/#Reference","content":" Reference BackendSelection.Algorithm  —  Type BackendSelection.Algorithm A type representing a backend for a function. For example, a function might have multiple backends implementations, which internally are selected with a  BackendSelection.Algorithm  type. This allows users to extend functionality with a new implementation but use the same interface. source BackendSelection.Backend  —  Type BackendSelection.Backend A type representing a backend for a function. For example, a function might have multiple backends implementations, which internally are selected with a  BackendSelection.Backend  type. This allows users to extend functionality with a new implementation but use the same interface. source BackendSelection.@Algorithm_str  —  Macro @Algorithm_str A convenience macro for writing  Algorithm  types, typically used when adding methods to a function that supports multiple backends. source BackendSelection.@Backend_str  —  Macro @Backend_str A convenience macro for writing  Backend  types, typically used when adding methods to a function that supports multiple backends. source"},{"id":139,"pagetitle":"Home","title":"ITensorPkgSkeleton.jl","ref":"/ITensorDocsNext/ITensorPkgSkeleton/stable/#ITensorPkgSkeleton.jl","content":" ITensorPkgSkeleton.jl"},{"id":140,"pagetitle":"Home","title":"Support","ref":"/ITensorDocsNext/ITensorPkgSkeleton/stable/#Support","content":" Support ITensorPkgSkeleton.jl is supported by the Flatiron Institute, a division of the Simons Foundation."},{"id":141,"pagetitle":"Home","title":"Installation instructions","ref":"/ITensorDocsNext/ITensorPkgSkeleton/stable/#Installation-instructions","content":" Installation instructions This package resides in the  ITensor/ITensorRegistry  local registry. In order to install, simply add that registry through your package manager. This step is only required once. julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\") or: julia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\") if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages. Then, the package can be added as usual through the package manager: julia> Pkg.add(\"ITensorPkgSkeleton\")"},{"id":142,"pagetitle":"Home","title":"Examples","ref":"/ITensorDocsNext/ITensorPkgSkeleton/stable/#Examples","content":" Examples using ITensorPkgSkeleton: ITensorPkgSkeleton\nITensorPkgSkeleton.generate(\"MyPackage\") The package \"MyPackage\" has been generated at \"/home/runner/.julia/dev\".\n\nTo register the package in the [ITensor registry](https://github.com/ITensor/ITensorRegistry), first add\nthe registry if you haven't already with:\n```julia\njulia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url = \"https://github.com/ITensor/ITensorRegistry\")\n```\nor:\n```julia\njulia> Pkg.Registry.add(url = \"git@github.com:ITensor/ITensorRegistry.git\")\n```\nif you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.\n\nThen, use `LocalRegistry.jl` to register the package. First, you should add `LocalRegistry.jl` in your global environment. Then, activate the package and call:\n```julia\nusing LocalRegistry: LocalRegistry\nLocalRegistry.register()\n``` Examples go here. This page was generated using  Literate.jl ."},{"id":145,"pagetitle":"Reference","title":"Reference","ref":"/ITensorDocsNext/ITensorPkgSkeleton/stable/reference/#Reference","content":" Reference ITensorPkgSkeleton.all_templates  —  Method all_templates()\n All available templates when constructing a package. Includes the following templates:  [\"project\", \"github\", \"gitignore\", \"examples\", \"test\", \"precommit\", \"src\", \"docs\", \"license\", \"benchmark\"] source ITensorPkgSkeleton.default_templates  —  Method default_templates()\n Default templates when constructing a package. Includes the following templates:  [\"project\", \"github\", \"gitignore\", \"examples\", \"test\", \"precommit\", \"src\", \"docs\", \"license\", \"benchmark\"] source ITensorPkgSkeleton.generate  —  Method generate(\n    pkgname;\n    path,\n    templates,\n    ignore_templates,\n    user_replacements...\n)\n Warning This function might overwrite existing code if you specify a path to a package that already exists, use with caution! See  PkgSkeleton.jl  for more details. If you are updating an existing package, make sure you save everything you want to keep (for example, commit all of your changes if it is a git repository). Generate a package template for a package, by default in the ITensor organization, or update an existing package. This is a wrapper around  PkgSkeleton.generate  but with extra functionality, custom templates used in the ITensor organization, and defaults biased towards creating a package in the ITensor organization. Examples julia> using ITensorPkgSkeleton: ITensorPkgSkeleton;\n\njulia> ITensorPkgSkeleton.generate(\"NewPkg\"; path = mktempdir());\n\njulia> ITensorPkgSkeleton.generate(\"NewPkg\"; path = mktempdir());\n\njulia> ITensorPkgSkeleton.generate(\n           \"NewPkg\";\n           path = mktempdir(),\n           templates = ITensorPkgSkeleton.default_templates()\n       );\n\njulia> ITensorPkgSkeleton.generate(\"NewPkg\"; path = mktempdir(), templates = [\"github\"]);\n\njulia> ITensorPkgSkeleton.generate(\n           \"NewPkg\"; path = mktempdir(), templates = [\"src\", \"github\"]\n       );\n\njulia> ITensorPkgSkeleton.generate(\n           \"NewPkg\"; path = mktempdir(), ignore_templates = [\"src\", \"github\"]\n       );\n\njulia> ITensorPkgSkeleton.generate(\"NewPkg\"; path = mktempdir(), ghuser = \"MyOrg\");\n\njulia> ITensorPkgSkeleton.generate(\n           \"NewPkg\"; path = mktempdir(), downstreampkgs = [\"ITensors\", \"ITensorMPS\"]\n       );\n Arguments pkgname::AbstractString : Name of the package (without the  .jl  extension). Replaces  {PKGNAME}  in the template. Keywords path::AbstractString : Path where the package will be generated. Defaults to the  development directory , i.e.  /home/runner/.julia/dev . templates : A list of templates to use. Select a subset of  ITensorPkgSkeleton.all_templates() = [\"project\", \"github\", \"gitignore\", \"examples\", \"test\", \"precommit\", \"src\", \"docs\", \"license\", \"benchmark\"] . Defaults to  ITensorPkgSkeleton.default_templates() = [\"project\", \"github\", \"gitignore\", \"examples\", \"test\", \"precommit\", \"src\", \"docs\", \"license\", \"benchmark\"] . ignore_templates : A list of templates to ignore. This is the same as setting  templates=setdiff(templates, ignore_templates) .    # Process downstream package information. downstreampkgs : Specify the downstream packages that depend on this package. This populates the  IntegrationTest.yml  matrix in the  github  template. If empty, the workflow defaults to  __none__ . uuid : Replaces  {UUID}  in the template. Defaults to the existing UUID in the  Project.toml  if the path points to an existing package, otherwise generates one randomly with  UUIDs.uuid4() . year : Replaces  {YEAR}  in the template. Year the package/repository was created. Defaults to the current year.    # Check if there are downstream tests. source"}]